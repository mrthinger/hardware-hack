File: ./software/main_malaria.py
show_config(cfp, configpath, main_gui):
Display and edit microscope configuration settings
Parameters: ConfigParser object, configuration file path, main GUI object

show_acq_config(cfm):
Display and edit acquisition configuration settings
Parameter: Configuration manager object
File: ./software/main_displacement_measurement.py
There are no method headers with docstring descriptions in the provided Python file. The file contains imports, argument parsing, and a main execution block, but no defined methods or functions with docstrings.
File: ./software/main_platereader.py
There are no method headers with docstring descriptions in the provided Python file. The file contains import statements, argument parsing, and the main execution block for launching a GUI application. It doesn't define any methods or functions with docstrings that could be extracted for indexing purposes.
File: ./software/main_hcs.py
show_config(cfp, configpath, main_gui):
Shows the configuration editor for microscope settings
Parameters: cfp (ConfigParser), configpath (str), main_gui (QMainWindow)

show_acq_config(cfm):
Shows the configuration editor for acquisition settings
Parameters: cfm (ConfigurationManager)
File: ./software/main_2cameras_sync.py
There are no method headers with docstring descriptions in the provided Python file. The file contains import statements, argument parsing, and the main execution block for a GUI application. It doesn't define any methods or functions with docstrings that could be extracted for indexing purposes.
File: ./software/main_simulation.py
There are no method headers with docstring descriptions in the provided Python file. The file contains import statements, environment variable setting, and a main block to initialize and run a QApplication. There are no defined functions or methods with docstrings that could be extracted for indexing purposes.
File: ./software/main_tiscamera_DZK250.py
There are no method headers with docstring descriptions in the provided Python file. The file contains imports, environment variable setting, and a simple main block to create and show a GUI application. There are no defined functions or methods with docstrings in this particular code snippet.
File: ./software/main_two_camera_focus_tracking.py
Here are the extracted method headers with docstring descriptions from the provided Python file:

def OctopiGUI():
    """Main GUI class for the Octopi application. Handles camera control, image display, and user interface elements."""

Note: This file doesn't contain any method definitions with docstrings. The only potentially relevant information for indexing would be the main class OctopiGUI(), which is imported from the gui module. The docstring provided is a general description based on the class name and typical functionality of such GUI classes in imaging applications.
File: ./software/main_6060.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def show_config(cfp, configpath, main_gui):
    """
    Display the configuration editor for microscope settings.
    
    Args:
    cfp: ConfigParser object
    configpath: Path to the configuration file
    main_gui: Main GUI object
    
    Functionality: Opens a ConfigEditorBackwardsCompatible widget
    """

def show_acq_config(cfm):
    """
    Display the configuration editor for acquisition settings.
    
    Args:
    cfm: Configuration manager object
    
    Functionality: Opens a ConfigEditorForAcquisitions widget
    """
File: ./software/main_two_cameras_daheng_tis.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def OctopiGUI():
    """Main GUI class for the Octopi application. Initializes and displays the user interface for controlling cameras and other hardware."""

Note: This file doesn't contain any method definitions with docstrings. It's primarily a script that sets up the QT environment and launches the main application window. The actual method definitions and docstrings are likely to be found in the imported 'gui' module (control.gui_2cameras_daheng_tis).
File: ./software/main_motion_only.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def OctopiGUI():
    """Main GUI class for the Octopi application. Initializes the user interface and handles interactions."""

Note: This file doesn't contain any method definitions with docstrings. It's primarily a script that sets up the QT environment and launches the main application window. The actual method definitions and docstrings are likely to be found in the imported modules, particularly in the 'control.gui_motion_only' module which is imported as 'gui'.
File: ./software/list_controllers.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

serial.tools.list_ports.comports()
    Return a list of serial port info objects.

    This function is a generator which yields SerialPortInfo objects. Each object contains information about a serial port, including its name, description, and hardware ID.

    Useful for indexing: serial ports, device enumeration, hardware detection

print(p.__dict__)
    Print the dictionary representation of a SerialPortInfo object.

    This method displays all attributes of the SerialPortInfo object, including device name, description, hardware ID, and other port-specific information.

    Useful for indexing: serial port details, device information, debugging
File: ./software/main_usbspectrometer.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def OctopiGUI(is_simulation=False):
    """
    Main GUI class for the USB spectrometer application.
    
    Args:
    is_simulation (bool): Flag to run the GUI with simulated hardware.
    
    Returns:
    QMainWindow: The main window of the application.
    
    Keywords: GUI, USB spectrometer, simulation
    """

Note: This method is not explicitly defined in the provided code, but it's implied by the usage in the main block. The actual implementation would be in the imported gui module.
File: ./software/toupcam_tests.py
get_sn_by_model(model): Retrieves the serial number for a given camera model.

Camera.__init__(sn, rotate_image_angle, flip_image): Initializes a Camera object with specified serial number, rotation angle, and flip settings.

Camera.open(): Opens the camera connection.

Camera.set_gain_mode(mode): Sets the gain mode of the camera.

Camera.set_resolution(width, height): Sets the resolution of the camera.

Camera.set_continuous_acquisition(): Sets the camera to continuous acquisition mode.

Camera.start_streaming(): Starts the camera streaming.

Camera.set_pixel_format(format): Sets the pixel format of the camera.

Camera.get_awb_ratios(): Gets the auto white balance ratios.

Camera.set_ROI(x, y, width, height): Sets the Region of Interest (ROI) for the camera.

Camera.read_frame(): Reads a frame from the camera.

Camera.close(): Closes the camera connection.
File: ./software/main_two_camera.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def __main__():
    """
    Main entry point of the application.
    Initializes the QApplication, creates the OctopiGUI instance, and starts the event loop.
    Keywords: QApplication, OctopiGUI, GUI initialization, event loop
    """

Note: This file doesn't contain any explicit method definitions with docstrings. The main functionality is in the `if __name__ == "__main__":` block, which I've represented as a `__main__()` function for indexing purposes. The actual methods and their docstrings are likely in the imported `gui` module (specifically in `control.gui_2cameras_async`).
File: ./software/main_volumeric_imaging.py
There are no method headers with docstring descriptions in the provided Python file. The file contains import statements, environment variable setting, and a simple main block to initialize and run a QApplication with a custom GUI class (OctopiGUI). There are no defined functions or methods with docstrings in this particular file.

To index this file, you might consider including:

1. The QT_API environment variable setting
2. The imported libraries, especially qtpy and the custom gui module
3. The main application initialization using QApplication
4. The use of the OctopiGUI class from the imported gui module

However, for more detailed method descriptions and docstrings, you would need to examine the contents of the imported gui module (control.gui_volumetric_imaging or the other commented-out options).
File: ./software/main_PDAF_calibration.py
There are no method headers with docstring descriptions in the provided Python file. The file contains imports, environment variable setting, and a main block to run a GUI application. There are no defined functions or methods with docstrings in this particular code snippet.

If you're looking to index this file, you might consider including information about:

1. The use of the QT_API environment variable
2. The import of qtpy and its components
3. The import of a custom module: control.gui_PDAF_calibration
4. The creation and execution of a GUI application using OctopiGUI

However, there are no specific method headers or docstrings to extract from this file.
File: ./software/main_PDAF_demo.py
There are no method headers with docstring descriptions in the provided Python file. The file contains imports, environment variable setting, and a main block to run a GUI application. There are no defined functions or methods with docstrings in this particular code snippet.

If you're looking to index this file, you might consider including information about:

1. The use of the QT_API environment variable
2. The import of qtpy and its components
3. The import of a custom module: control.gui_PDAF_demo
4. The creation and execution of a GUI application using OctopiGUI

However, there are no specific method headers or docstrings to extract from this file.
File: ./software/main.py
There are no method headers with docstring descriptions in the provided Python file. The file contains imports, environment variable setting, argument parsing, and the main execution block for a GUI application. It doesn't define any methods or functions with docstrings that could be extracted for indexing purposes.
File: ./software/main_tiscamera_camera_only.py
There are no method headers with docstring descriptions in the provided Python file. The file contains imports, environment variable setting, and a simple main block to create and show a GUI application. There are no defined functions or methods with docstrings in this particular code snippet.

If you're looking to index this file, you might consider including information about:

1. The use of the QT_API environment variable
2. The import of qtpy and its components
3. The import of a custom module: control.gui_camera_only_tiscamera
4. The creation of a QApplication instance
5. The instantiation of an OctopiGUI object from the gui module
6. The execution of the Qt event loop

However, for more detailed method descriptions and docstrings, you would need to examine the contents of the imported gui module (control.gui_camera_only_tiscamera).
File: ./software/main_tiscamera_simulation.py
There are no method headers with docstring descriptions in the provided Python file. The file appears to be a simple script that sets up a QT application and launches a GUI. It doesn't contain any function or method definitions.

The file does include some import statements and environment variable settings that might be useful for indexing:

- QT_API environment variable set to "pyqt5"
- Uses qtpy library
- Imports from qtpy.QtCore, qtpy.QtWidgets, and qtpy.QtGui
- Imports a custom module: control.gui_tiscamera_simulation (with commented out alternatives)
- Creates and runs an instance of OctopiGUI
File: ./software/main_camera_only.py
There are no method headers with docstring descriptions in the provided Python file. The file appears to be a simple script that sets up a QT application and launches a GUI. It doesn't contain any function or method definitions.

The file does import a module named 'gui' from different possible locations (commented out alternatives are visible), which might contain the actual GUI implementation and methods. To index the codebase effectively, you'd need to examine the contents of the imported 'gui' module, specifically the 'OctopiGUI' class it contains.

Key elements to index from this file might include:
- Use of QT_API environment variable set to "pyqt5"
- Import of qtpy library
- Use of QApplication
- Instantiation of OctopiGUI class from the gui module
File: ./software/tools/list_cameras.py
def main():
    """
    Main function that creates a device manager, updates the device list, and prints information about enumerated devices.
    
    Uses: gx.DeviceManager, update_device_list
    Handles: Device enumeration, Device information printing
    """
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/sample/GxSingleCamColor/GxSingleCamColor.py
def main():
    """
    Main function to acquire color images continuously from a camera and display them.
    Initializes device manager, opens camera, sets acquisition parameters, captures images,
    improves image quality, and displays the results.
    
    Keywords: camera, image acquisition, color image, image processing, device management
    """
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/api/setup.py
There are no method headers with docstring descriptions in the provided Python file. The file appears to be a setup script for a Python package named 'gxipy'. It contains a setup() function call with package metadata, but no custom methods or functions with docstrings.
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/sample/GxSingleCamMono/GxSingleCamMono.py
def main():
    """
    Main function to acquire and display mono images continuously.
    - Initializes device manager
    - Opens first available camera
    - Sets acquisition parameters (exposure, gain)
    - Captures and displays images
    - Prints frame information
    - Closes device after acquisition
    Keywords: image acquisition, mono image, camera control, frame display
    """
File: ./software/main_toupcam_IMX571.py
There are no method headers with docstring descriptions in the provided Python file. The file contains imports, environment variable setting, argument parsing, and a main execution block. It doesn't define any methods or functions with docstrings that could be extracted for indexing purposes.

The file appears to be a main script for launching a GUI application using Qt and a custom module named 'gui_toupcam_IMX571'. It includes options for running in simulation mode.

Key elements for indexing might include:
- QT_API environment variable setting
- Use of qtpy for Qt bindings
- Importing of custom GUI module (gui_toupcam_IMX571)
- Command-line argument for simulation mode
- Creation and execution of QApplication
File: ./software/tools/script_flip_i_indices.py
def get_ny(slide_path):
    # Retrieves the Ny value from the acquisition parameters JSON file in the given slide path

def get_inverted_y_filepath(filepath, channel_name, Ny):
    """Given a channel name to strip and a number of y indices, returns
    a version of the slide name with its y-index inverted."""

def invert_y_in_folder(fovs_path, channel_names, Ny):
    """Given a folder with FOVs, channel names, and Ny, inverts the y-indices of all of them"""

def invert_y_in_slide(slide_path):
    # Inverts y-indices for all FOVs in a slide, including updating the coordinates CSV file
File: ./software/tools/script_create_configurations_xml.py
This Python file does not contain any method headers with docstring descriptions. The file primarily consists of XML element creation and manipulation using the lxml library. It creates an XML structure representing different imaging modes with various attributes.

Key elements to index for documentation purposes:

- XML structure creation using lxml.etree
- Creation of multiple 'mode' elements with attributes like ID, Name, ExposureTime, AnalogGain, IlluminationSource, IlluminationIntensity, CameraSN, ZOffset, PixelFormat
- Different imaging modes: BF LED matrix (full, left half, right half, color PDAF), Fluorescence (405 nm, 488 nm, 638 nm)
- Writing the XML structure to a file named 'configurations.xml'
File: ./software/main_tiscamera.py
There are no method headers with docstring descriptions in the provided Python file. The file appears to be a simple script that sets up a QT application and launches a GUI. It doesn't contain any function or method definitions.

The file does import a module named 'gui' from different possible locations (commented out alternatives are visible), which might contain the actual GUI implementation and methods. To index the codebase effectively, you'd need to examine the contents of the imported 'gui' module, specifically the 'OctopiGUI' class it contains.

Key elements to index from this file might include:
- Use of QT_API environment variable set to "pyqt5"
- Import of qtpy library
- Use of QApplication
- Instantiation of OctopiGUI class from the gui module
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/api/gxipy/__init__.py
Here are the extracted method headers with docstring descriptions from the provided Python file:

No method headers with docstrings were found in the given Python file.

The file contains:
- Import statements from gxipy.gxiapi and gxipy.gxidef
- Definition of __all__ list
- Definition of __version__ string

There are no function or method definitions with docstrings in this particular file.
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/sample/GxAcquireSoftTrigger/GxAcquireSoftTrigger.py
def acq_color(device, num):
    """
    Acquisition function of color device
    :param device: device object[Device]
    :param num: number of acquisition images[int]
    """

def acq_mono(device, num):
    """
    Acquisition function of mono device
    :param device: device object[Device]
    :param num: number of acquisition images[int]
    """

def main():
    """
    Main function to demonstrate image acquisition using soft trigger for mono or color cameras
    Initializes device, sets exposure and gain, configures trigger mode, acquires and displays images
    """
File: ./software/tools/script_stitch_slide.py
get_pixel_size(slide_path, default_pixel_size=1.85, default_tube_lens_mm=50.0, default_objective_tube_lens_mm=180.0, default_magnification=20.0):
Calculates the pixel size for a microscope slide image based on acquisition parameters. Returns the pixel size in xy dimensions.

get_overlap(slide_path, **kwargs):
Computes the overlap percentage between adjacent fields of view in a slide image. Returns the overlap percentage.

get_time_indices(slide_path):
Retrieves the time indices from the acquisition parameters of a slide. Returns a list of time indices.

get_channels(slide_path):
Extracts channel names from the configurations XML file of a slide. Returns a list of channel names.

get_z_indices(slide_path):
Retrieves the z-stack indices from the acquisition parameters of a slide. Returns a list of z indices.

get_coord_names(slide_path):
Extracts coordinate names from the image filenames in a slide folder. Returns a list of coordinate names.

stitch_slide_from_path(slide_path, **kwargs):
Stitches together images from a slide folder using various parameters and the stitch_slide function.

print_usage():
Prints usage instructions for the script, including command-line arguments and their descriptions.
File: ./software/tools/script_create_zarr_from_acquisition.py
read_configurations_used(filepath):
Reads configuration data from an XML file and returns a sorted list of configuration names.

get_dimensions_for_dataset(dataset_folder_path, sensor_pixel_size_um_default = 1.0, objective_magnification_default=1.0, Nz_override = None, Nt_override = None):
Returns a dictionary containing dataset dimensions and metadata, including image size, pixel size, channel information, and FOV properties.

create_dask_array_for_single_fov(dataset_folder_path, x=0, y=0, sensor_pixel_size_um_default = 1.0, objective_magnification_default=1.0, z_to_use=None, t_to_use=None, well=0):
Creates a Dask array for a single field of view (FOV) from image files in the dataset folder.

create_zarr_for_single_fov(dataset_folder_path, saving_path, x=0, y=0, sensor_pixel_size_um=1.0, objective_magnification=1.0, z_to_use=None, t_to_use = None, well=0):
Creates an OME-Zarr file for a single field of view (FOV) from the dataset and saves it to the specified path.
File: ./software/tools/script_create_desktop_shortcut.py
def create_desktop_shortcut_simulation(directory_path, script_name):
    """
    Creates a desktop shortcut for launching a simulation.
    
    Args:
    directory_path (str): Path to the directory containing the script
    script_name (str): Name of the script to be executed
    
    Returns:
    str: Path to the created desktop shortcut
    
    Functionality:
    - Generates a .desktop file for a simulation shortcut
    - Sets up the shortcut with appropriate icon and execution command
    - Creates the shortcut on the user's desktop
    - Sets appropriate permissions for the shortcut file
    """

def create_desktop_shortcut(directory_path, script_name):
    """
    Creates a desktop shortcut for launching a script.
    
    Args:
    directory_path (str): Path to the directory containing the script
    script_name (str): Name of the script to be executed
    
    Returns:
    str: Path to the created desktop shortcut
    
    Functionality:
    - Generates a .desktop file for a script shortcut
    - Sets up the shortcut with appropriate icon and execution command
    - Creates the shortcut on the user's desktop
    - Sets appropriate permissions for the shortcut file
    """

def main():
    """
    Main function to create desktop shortcuts for Squid scripts.
    
    Functionality:
    - Prompts user for directory path and script name
    - Asks if the shortcut is for simulation mode
    - Calls appropriate function to create desktop shortcut
    - Prints the path of the created shortcut
    """
File: ./software/control/widgets_tracking.py
Here are the extracted method headers with docstring descriptions:

def __init__(self, multipointController, navigationController, main=None, *args, **kwargs):
    """
    Initialize the TrackingControllerWidget.
    
    Args:
    multipointController: Controller for multipoint operations
    navigationController: Controller for navigation operations
    main: Main application window (optional)
    *args: Variable length argument list
    **kwargs: Arbitrary keyword arguments
    
    Initializes the widget, sets up controllers, and configures the frame style.
    """
File: ./software/control/gui_2cameras_async_focus_tracking.py
Here are the extracted method headers with docstring descriptions:

def __init__(self, *args, **kwargs):
    """Initialize OctopiGUI class. Sets up cameras, controllers, widgets, layouts, and connections."""

def closeEvent(self, event):
    """Handle closing of the application. Stops live views, closes cameras and windows."""
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/api/gxipy/dxwrapper.py
dx_get_gamma_lut(gamma_param):
Calculates gamma lookup table (RGB24)
Parameters: gamma_param (range 0.1 to 10)
Returns: status, gamma_lut, lut_length

dx_get_contrast_lut(contrast_param):
Calculates contrast lookup table (RGB24)
Parameters: contrast_param (range -50 to 100)
Returns: status, contrast_lut, lut_length

dx_raw8_to_rgb24(input_address, output_address, width, height, convert_type, bayer_type, flip):
Converts Raw8 to Rgb24
Parameters: input_address, output_address, width, height, convert_type, bayer_type, flip
Returns: status

dx_raw16_to_raw8(input_address, out_address, width, height, valid_bits):
Converts Raw16 to Raw8
Parameters: input_address, out_address, width, height, valid_bits
Returns: status

dx_image_improvement(input_address, output_address, width, height, color_correction_param, contrast_lut, gamma_lut):
Performs image quality improvement
Parameters: input_address, output_address, width, height, color_correction_param, contrast_lut, gamma_lut
Returns: status

dx_saturation(input_address, output_address, image_size, factor):
Adjusts saturation (RGB24)
Parameters: input_address, output_address, image_size, factor (range 0 to 128)
Returns: status

dx_auto_raw_defective_pixel_correct(inout_address, width, height, bit_num):
Performs auto raw defective pixel correction
Parameters: inout_address, width, height, bit_num (range 8 to 16)
Returns: status

dx_sharpen_24b(input_address, output_address, width, height, factor):
Performs sharpen adjustment (RGB24)
Parameters: input_address, output_address, width, height, factor (range 0.1 to 5.0)
Returns: status
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/api/build/lib/gxipy/dxwrapper.py
dx_get_gamma_lut(gamma_param):
Calculates gamma lookup table (RGB24)
Parameters: gamma_param (range 0.1 to 10)
Returns: status, gamma_lut, lut_length

dx_get_contrast_lut(contrast_param):
Calculates contrast lookup table (RGB24)
Parameters: contrast_param (range -50 to 100)
Returns: status, contrast_lut, lut_length

dx_raw8_to_rgb24(input_address, output_address, width, height, convert_type, bayer_type, flip):
Converts Raw8 to Rgb24
Parameters: input_address, output_address, width, height, convert_type, bayer_type, flip
Returns: status

dx_raw16_to_raw8(input_address, out_address, width, height, valid_bits):
Converts Raw16 to Raw8
Parameters: input_address, out_address, width, height, valid_bits
Returns: status

dx_image_improvement(input_address, output_address, width, height, color_correction_param, contrast_lut, gamma_lut):
Performs image quality improvement
Parameters: input_address, output_address, width, height, color_correction_param, contrast_lut, gamma_lut
Returns: status

dx_saturation(input_address, output_address, image_size, factor):
Adjusts saturation (RGB24)
Parameters: input_address, output_address, image_size, factor (range 0 to 128)
Returns: status

dx_auto_raw_defective_pixel_correct(inout_address, width, height, bit_num):
Performs auto raw defective pixel correction
Parameters: inout_address, width, height, bit_num (range 8 to 16)
Returns: status

dx_sharpen_24b(input_address, output_address, width, height, factor):
Performs sharpen adjustment (RGB24)
Parameters: input_address, output_address, width, height, factor (range 0.1 to 5.0)
Returns: status
File: ./software/tools/stitcher.py
compute_overlap_percent(deltaX, deltaY, image_width, image_height, pixel_size_xy, min_overlap=0):
Helper function to calculate percent overlap between images in a grid

stitch_slide_mp(*args, **kwargs):
Multiprocessing wrapper for stitch_slide function

migrate_tile_config(fovs_path, coord_name, channel_name_source, z_index_source, channel_name_target, z_index_target):
Migrates tile configuration from one channel/z-index to another

stitch_slide(slide_path, time_indices, channels, z_indices, coord_names=[''], overlap_percent=10, reg_threshold=0.30, avg_displacement_threshold=2.50, abs_displacement_threshold=3.50, tile_downsampling=0.5, recompute_overlap=False, **kwargs):
Main function to stitch a slide with multiple time points, channels, and z-indices

Stitcher.stitch_slide(self, slide_path, time_indices, channels, z_indices, coord_names=[''], overlap_percent = 10, reg_threshold=0.30, avg_displacement_threshold=2.50, abs_displacement_threshold=3.50, tile_downsampling=0.5, recompute_overlap=False, **kwargs):
Stitches a slide with multiple time points, channels, and z-indices

Stitcher.stitch_single_time_point(self, slide_path, time_index, channels, z_indices, coord_names = [''], overlap_percent=10, reg_threshold=0.30, avg_displacement_threshold=2.50, abs_displacement_threshold=3.50, tile_downsampling=0.5, recompute_overlap=False, **kwargs):
Stitches a single time point with multiple channels and z-indices

Stitcher.stitch_single_channel_from_tile_config(self, fovs_path, channel_name, z_index, coord_name):
Stitches images using grid/collection stitching, reading registered positions from a tile configuration path

Stitcher.stitch_single_channel(self, fovs_path, channel_name, z_index, coord_name='', overlap_percent=10, reg_threshold = 0.30, avg_displacement_threshold=2.50, abs_displacement_threshold=3.50, tile_downsampling=0.5, recompute_overlap=False):
Stitches images using grid/collection stitching with filename-defined positions

images_identical(im_1, im_2):
Return True if two opencv arrays are exactly the same

combine_stitched_channels(stitched_image_folder_path, write_multiscale_tiff = False, pixel_size_um=1.0, tile_side_length=1024, subresolutions=3):
Combines the three channel images created into one TIFF
File: ./software/control/_multipoint_custom_script_entry.py
multipoint_custom_script_entry(multiPointWorker, time_point, current_path, coordinate_id, coordiante_name, i, j):
    """
    Custom script entry point for multipoint acquisition.
    Handles autofocus, z-stacking, image acquisition, and saving for multiple configurations.
    Manages reflection autofocus, z-stack movement, and image processing.
    Saves acquired images and spectra, updates coordinates, and handles abort requests.
    """
File: ./software/control/gui_malaria.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def __init__(self, is_simulation = False, *args, **kwargs):
    """Initialize the OctopiGUI class. Sets up camera, microcontroller, controllers, widgets, and connections."""

def closeEvent(self, event):
    """Handle closing of the application. Caches position, homes stage, stops live view, closes devices."""
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/api/gxipy/gxidef.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

class GxFrameStatusList:
    """Frame state codes for image processing"""

class GxDeviceClassList:
    """Device type codes for different vision devices"""

class GxAccessMode:
    """Access modes for opening devices"""

class GxAccessStatus:
    """Current access status of devices"""

class GxIPConfigureModeList:
    """IP configuration modes for network devices"""

class GxPixelSizeEntry:
    """Pixel size entries in bits per pixel"""

class GxPixelColorFilterEntry:
    """Pixel color filter patterns"""

class GxPixelFormatEntry:
    """Pixel format entries for different color and bit depths"""

class GxAcquisitionModeEntry:
    """Acquisition modes for image capture"""

class GxTriggerSourceEntry:
    """Trigger source options for image acquisition"""

class GxTriggerActivationEntry:
    """Trigger activation edge types"""

class GxExposureModeEntry:
    """Exposure modes for image capture"""

class GxUserOutputSelectorEntry:
    """User output selector options"""

class GxUserOutputModeEntry:
    """User output mode options"""

class GxGainSelectorEntry:
    """Gain selector options for color channels"""

class GxBlackLevelSelectEntry:
    """Black level selector options for color channels"""

class GxBalanceRatioSelectorEntry:
    """Balance ratio selector options for color channels"""

class GxAALightEnvironmentEntry:
    """Auto algorithm light environment options"""

class GxUserSetEntry:
    """User set options for camera settings"""

class GxAWBLampHouseEntry:
    """Auto white balance lamp house options"""

class GxTestPatternEntry:
    """Test pattern options for image generation"""

class GxTriggerSelectorEntry:
    """Trigger selector options"""

class GxLineSelectorEntry:
    """Line selector options for I/O lines"""

class GxLineModeEntry:
    """Line mode options for I/O lines"""

class GxLineSourceEntry:
    """Line source options for output lines"""

class GxEventSelectorEntry:
    """Event selector options"""

class GxLutSelectorEntry:
    """LUT selector options"""

class GxTransferControlModeEntry:
    """Transfer control mode options"""

class GxTransferOperationModeEntry:
    """Transfer operation mode options"""

class GxTestPatternGeneratorSelectorEntry:
    """Test pattern generator selector options"""

class GxChunkSelectorEntry:
    """Chunk data selector options"""

class GxTimerSelectorEntry:
    """Timer selector options"""

class GxTimerTriggerSourceEntry:
    """Timer trigger source options"""

class GxCounterSelectorEntry:
    """Counter selector options"""

class GxCounterEventSourceEntry:
    """Counter event source options"""

class GxCounterResetSourceEntry:
    """Counter reset source options"""

class GxCounterResetActivationEntry:
    """Counter reset activation options"""

class GxBinningHorizontalModeEntry:
    """Horizontal binning mode options"""

class GxBinningVerticalModeEntry:
    """Vertical binning mode options"""

class GxAcquisitionStatusSelectorEntry:
    """Acquisition status selector options"""

class GxGammaModeEntry:
    """Gamma correction mode options"""

class GxColorTransformationModeEntry:
    """Color transformation mode options"""

class GxColorTransformationValueSelectorEntry:
    """Color transformation value selector options"""

class GxAutoEntry:
    """Auto mode options"""

class GxSwitchEntry:
    """On/Off switch options"""

class GxRegionSendModeEntry:
    """Region send mode options"""

class GxRegionSelectorEntry:
    """Region selector options"""

class DxBayerConvertType:
    """Bayer conversion algorithm options"""

class DxValidBit:
    """Image valid bit options"""

class DxImageMirrorMode:
    """Image mirroring mode options"""
File: ./software/control/gui_displacement_measurement.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def __init__(self, is_simulation = False, *args, **kwargs):
    """
    Initialize the OctopiGUI class.
    Sets up the main window, camera, microcontroller, and various controllers and widgets.
    Configures the GUI layout and connections between components.
    """

def closeEvent(self, event):
    """
    Handle the window close event.
    Performs cleanup operations such as stopping live view, closing camera and microcontroller connections,
    and closing any additional windows.
    """
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/api/gxipy/gxwrapper.py
Here are the extracted method headers with docstring descriptions:

def gx_init_lib():
    """
    :brief      Initialize the device library for some resource application operations
    :return:    None
    """

def gx_close_lib():
    """
    :brief      Close the device library to release resources.
    :return:    None
    """

def gx_get_last_error(size=1024):
    """
    :brief      To get the latest error descriptions information of the program
    :param      size:           string buff length(size=1024)
                                Type: Int, Minnum: 0
    :return:    status:         State return value, See detail in GxStatusList
                err_code:       Return the last error code
                err_content:    the latest error descriptions information of the program
    """

def gx_update_device_list(time_out=200):
    """
    :brief      Enumerating currently all available devices in subnet and gets the number of devices.
    :param      time_out:           The timeout time of enumeration (unit: ms).
                                    Type: Int, Minimum:0
    :return:    status:             State return value, See detail in GxStatusList
                device_num:         The number of devices
    """

def gx_update_all_device_list(time_out=200):
    """
    :brief      Enumerating currently all available devices in entire network and gets the number of devices
    :param      time_out:           The timeout time of enumeration (unit: ms).
                                    Type: Int, Minimum: 0
    :return:    status:             State return value, See detail in GxStatusList
                device_num:         The number of devices
    """

def gx_get_all_device_base_info(devices_num):
    """
    :brief      To get the basic information of all the devices
    :param      devices_num:        The number of devices
                                    Type: Int, Minimum: 0
    :return:    status:             State return value, See detail in GxStatusList
                device_ip_info:     The structure pointer of the device information(GxDeviceIPInfo)
    """

def gx_open_device_by_index(index):
    """
    :brief      Open the device by a specific Index(1, 2, 3, ...)
    :param      index:          Device index
                                Type: Int, Minimum: 1
    :return:    status:         State return value, See detail in GxStatusList
                handle:         The device handle returned by the interface
    """

def gx_open_device(open_param):
    """
    :brief      Open the device by a specific unique identification, such as: SN, IP, MAC, Index etc.
    :param      open_param:     The open device parameter which is configurated by the user.
                                Type: GxOpenParam
    :return:    status:         State return value, See detail in GxStatusList
                handle:         The device handle returned by the interface
    """

def gx_close_device(handle):
    """
    :brief      Specify the device handle to close the device
    :param      handle:     The device handle that the user specified to close.
                            Type: Long, Greater than 0
    :return:    status:     State return value, See detail in GxStatusList
    """

def gx_get_feature_name(handle, feature_id):
    """
    :brief      Get the string description for the feature code
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: Int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                name:           The string description for the feature code
    """

def gx_is_implemented(handle, feature_id):
    """
    :brief      Inquire the current camera whether support a special feature.
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                is_implemented: To return the result whether is support this feature
    """

def gx_is_readable(handle, feature_id):
    """
    :brief      Inquire if a feature code is currently readable
    :param      handle:             The handle of the device
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                is_readable:        To return the result whether the feature code ID is readable
    """

def gx_is_writable(handle, feature_id):
    """
    :brief      Inquire if a feature code is currently writable
    :param      handle:             The handle of the device.
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                is_writeable:       To return the result whether the feature code ID is writable(Bool)
    """

def gx_get_int_range(handle, feature_id):
    """
    :brief      To get the minimum value, maximum value and steps of the int type
    :param      handle:         The handle of the device.
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                int_range:      The structure of range description(GxIntRange)
    """

def gx_get_int(handle, feature_id):
    """
    :brief      Get the current value of the int type.
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                int_value:      Get the current value of the int type
    """

def gx_set_int(handle, feature_id, int_value):
    """
    :brief      Set the value of int type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID.
                                Type: int, Greater than 0
    :param      int_value:      The value that the user will set
                                Type: long, minnum:0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_float_range(handle, feature_id):
    """
    :brief      To get the minimum value, maximum value, stepsand unit of the float type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                float_range:    The description structure(GxFloatRange)
    """

def gx_set_float(handle, feature_id, float_value):
    """
    :brief      Set the value of float type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :param      float_value:    The float value that the user will set
                                Type: double
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_float(handle, feature_id):
    """
    :brief      Get the value of float type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_enum_entry_nums(handle, feature_id):
    """
    :brief      Get the number of the options for the enumeration item
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                enum_num:       The number of the options for the enumeration item
    """

def gx_get_enum_description(handle, feature_id, enum_num):
    """
    :brief      To get the description information of the enumerated type values
                the number of enumerated items and the value and descriptions of each item
                please reference GxEnumDescription.
    :param      handle:             The handle of the device
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :param      enum_num:           The number of enumerated information
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                enum_description:   Enumerated information array(GxEnumDescription)
    """

def gx_get_enum(handle, feature_id):
    """
    :brief      To get the current enumeration value
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                enum_value:     Get the current enumeration value
    """

def gx_set_enum(handle, feature_id, enum_value):
    """
    :brief      Set the enumeration value
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :param      enum_value:     Set the enumeration value
                                Type: int
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_bool(handle, feature_id):
    """
    :brief      Get the value of bool type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                boot_value:     the value of bool type
    """

def gx_set_bool(handle, feature_id, bool_value):
    """
    :brief      Set the value of bool type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :param      bool_value:     The bool value that the user will set
                                Type: Bool
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_string_length(handle, feature_id):
    """
    :brief      Get the current value length of the character string type. Unit: byte
    :param      handle:             The handle of the device
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                string_length:      the current value length of the character string type
    """

def gx_get_string_max_length(handle, feature_id):
    """
    :brief      Get the maximum length of the string type value,  Unit: byte
    :param      handle:             The handle of the device
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                string_max_length:  the maximum length of the string type value
    """

def gx_get_string(handle, feature_id):
    """
    :brief      Get the content of the string type value
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_set_string(handle, feature_id, content):
    """
    :brief      Set the content of the string value
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :param      content:        The string will be setting(str)
                                Type: str
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_buffer_length(handle, feature_id):
    """
    :brief      Get the length of the chunk data and the unit is byte,
                the user can apply the buffer based on the length obtained,
                and then call the gx_get_buffer to get the chunk data.
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                buff_length:    Buff length, Unit: byte
    """

def gx_get_buffer(handle, feature_id):
    """
    :brief      Get the chunk data
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                buff:           chunk data
    """

def gx_set_buffer(handle, feature_id, buff, buff_size):
    """
    :brief      Set the chunk data
    :param      handle:         The handle of the device
    :param      feature_id:     The feature code ID
                                Type: long, Greater than 0
    :param      buff:           chunk data buff
                                Type: Ctype array
    :param      buff_size:      chunk data buff size
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_send_command(handle, feature_id):
    """
    :brief      Send the command
    :param      handle:         The handle of the device
                                Type: long, Greater than 0
    :param      feature_id:     The feature code ID.
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_image(handle, frame_data, time_out=200):
    """
    :brief      After starting acquisition, you can call this function to get images directly.
                Noting that the interface can not be mixed with the callback capture mode.
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      frame_data:     [out]User introduced to receive the image data
                                Type: GxFrameData
    :param      time_out:       The timeout time of capture image.(unit: ms)
                                Type: int, minnum: 0
    :return:    status:         State return value
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/api/build/lib/gxipy/gxwrapper.py
Here are the extracted method headers with docstring descriptions:

def gx_init_lib():
    """
    :brief      Initialize the device library for some resource application operations
    :return:    None
    """

def gx_close_lib():
    """
    :brief      Close the device library to release resources.
    :return:    None
    """

def gx_get_last_error(size=1024):
    """
    :brief      To get the latest error descriptions information of the program
    :param      size:           string buff length(size=1024)
                                Type: Int, Minnum: 0
    :return:    status:         State return value, See detail in GxStatusList
                err_code:       Return the last error code
                err_content:    the latest error descriptions information of the program
    """

def gx_update_device_list(time_out=200):
    """
    :brief      Enumerating currently all available devices in subnet and gets the number of devices.
    :param      time_out:           The timeout time of enumeration (unit: ms).
                                    Type: Int, Minimum:0
    :return:    status:             State return value, See detail in GxStatusList
                device_num:         The number of devices
    """

def gx_update_all_device_list(time_out=200):
    """
    :brief      Enumerating currently all available devices in entire network and gets the number of devices
    :param      time_out:           The timeout time of enumeration (unit: ms).
                                    Type: Int, Minimum: 0
    :return:    status:             State return value, See detail in GxStatusList
                device_num:         The number of devices
    """

def gx_get_all_device_base_info(devices_num):
    """
    :brief      To get the basic information of all the devices
    :param      devices_num:        The number of devices
                                    Type: Int, Minimum: 0
    :return:    status:             State return value, See detail in GxStatusList
                device_ip_info:     The structure pointer of the device information(GxDeviceIPInfo)
    """

def gx_open_device_by_index(index):
    """
    :brief      Open the device by a specific Index(1, 2, 3, ...)
    :param      index:          Device index
                                Type: Int, Minimum: 1
    :return:    status:         State return value, See detail in GxStatusList
                handle:         The device handle returned by the interface
    """

def gx_open_device(open_param):
    """
    :brief      Open the device by a specific unique identification, such as: SN, IP, MAC, Index etc.
    :param      open_param:     The open device parameter which is configurated by the user.
                                Type: GxOpenParam
    :return:    status:         State return value, See detail in GxStatusList
                handle:         The device handle returned by the interface
    """

def gx_close_device(handle):
    """
    :brief      Specify the device handle to close the device
    :param      handle:     The device handle that the user specified to close.
                            Type: Long, Greater than 0
    :return:    status:     State return value, See detail in GxStatusList
    """

def gx_get_feature_name(handle, feature_id):
    """
    :brief      Get the string description for the feature code
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: Int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                name:           The string description for the feature code
    """

def gx_is_implemented(handle, feature_id):
    """
    :brief      Inquire the current camera whether support a special feature.
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                is_implemented: To return the result whether is support this feature
    """

def gx_is_readable(handle, feature_id):
    """
    :brief      Inquire if a feature code is currently readable
    :param      handle:             The handle of the device
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                is_readable:        To return the result whether the feature code ID is readable
    """

def gx_is_writable(handle, feature_id):
    """
    :brief      Inquire if a feature code is currently writable
    :param      handle:             The handle of the device.
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                is_writeable:       To return the result whether the feature code ID is writable(Bool)
    """

def gx_get_int_range(handle, feature_id):
    """
    :brief      To get the minimum value, maximum value and steps of the int type
    :param      handle:         The handle of the device.
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                int_range:      The structure of range description(GxIntRange)
    """

def gx_get_int(handle, feature_id):
    """
    :brief      Get the current value of the int type.
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                int_value:      Get the current value of the int type
    """

def gx_set_int(handle, feature_id, int_value):
    """
    :brief      Set the value of int type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID.
                                Type: int, Greater than 0
    :param      int_value:      The value that the user will set
                                Type: long, minnum:0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_float_range(handle, feature_id):
    """
    :brief      To get the minimum value, maximum value, stepsand unit of the float type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                float_range:    The description structure(GxFloatRange)
    """

def gx_set_float(handle, feature_id, float_value):
    """
    :brief      Set the value of float type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :param      float_value:    The float value that the user will set
                                Type: double
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_float(handle, feature_id):
    """
    :brief      Get the value of float type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_enum_entry_nums(handle, feature_id):
    """
    :brief      Get the number of the options for the enumeration item
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                enum_num:       The number of the options for the enumeration item
    """

def gx_get_enum_description(handle, feature_id, enum_num):
    """
    :brief      To get the description information of the enumerated type values
                the number of enumerated items and the value and descriptions of each item
                please reference GxEnumDescription.
    :param      handle:             The handle of the device
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :param      enum_num:           The number of enumerated information
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                enum_description:   Enumerated information array(GxEnumDescription)
    """

def gx_get_enum(handle, feature_id):
    """
    :brief      To get the current enumeration value
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                enum_value:     Get the current enumeration value
    """

def gx_set_enum(handle, feature_id, enum_value):
    """
    :brief      Set the enumeration value
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :param      enum_value:     Set the enumeration value
                                Type: int
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_bool(handle, feature_id):
    """
    :brief      Get the value of bool type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                boot_value:     the value of bool type
    """

def gx_set_bool(handle, feature_id, bool_value):
    """
    :brief      Set the value of bool type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :param      bool_value:     The bool value that the user will set
                                Type: Bool
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_string_length(handle, feature_id):
    """
    :brief      Get the current value length of the character string type. Unit: byte
    :param      handle:             The handle of the device
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                string_length:      the current value length of the character string type
    """

def gx_get_string_max_length(handle, feature_id):
    """
    :brief      Get the maximum length of the string type value,  Unit: byte
    :param      handle:             The handle of the device
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                string_max_length:  the maximum length of the string type value
    """

def gx_get_string(handle, feature_id):
    """
    :brief      Get the content of the string type value
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_set_string(handle, feature_id, content):
    """
    :brief      Set the content of the string value
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :param      content:        The string will be setting(str)
                                Type: str
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_buffer_length(handle, feature_id):
    """
    :brief      Get the length of the chunk data and the unit is byte,
                the user can apply the buffer based on the length obtained,
                and then call the gx_get_buffer to get the chunk data.
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                buff_length:    Buff length, Unit: byte
    """

def gx_get_buffer(handle, feature_id):
    """
    :brief      Get the chunk data
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                buff:           chunk data
    """

def gx_set_buffer(handle, feature_id, buff, buff_size):
    """
    :brief      Set the chunk data
    :param      handle:         The handle of the device
    :param      feature_id:     The feature code ID
                                Type: long, Greater than 0
    :param      buff:           chunk data buff
                                Type: Ctype array
    :param      buff_size:      chunk data buff size
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_send_command(handle, feature_id):
    """
    :brief      Send the command
    :param      handle:         The handle of the device
                                Type: long, Greater than 0
    :param      feature_id:     The feature code ID.
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_image(handle, frame_data, time_out=200):
    """
    :brief      After starting acquisition, you can call this function to get images directly.
                Noting that the interface can not be mixed with the callback capture mode.
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      frame_data:     [out]User introduced to receive the image data
                                Type: GxFrameData
    :param      time_out:       The timeout time of capture image.(unit: ms)
                                Type: int, minnum: 0
    :return:    status:         State return value
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/api/build/lib/gxipy/gxiapi.py
Here are the method headers with docstring descriptions extracted from the Python file:

DeviceManager.__get_device_info_list:
"""
:brief      Convert GxDeviceBaseInfo and GxDeviceIPInfo to device info list
:param      base_info:  device base info list[GxDeviceBaseInfo]
:param      ip_info:    device ip info list[GxDeviceIPInfo]
:param      num:        device number
:return:    device info list
"""

DeviceManager.__get_ip_info:
"""
:brief      Get the network information
"""

DeviceManager.update_device_list:
"""
:brief      enumerate the same network segment devices
:param      timeout:    Enumeration timeout, range:[0, 0xFFFFFFFF]
:return:    dev_num:    device number
            device_info_list: all device info list
"""

DeviceManager.update_all_device_list:
"""
:brief      Enumerate devices on different network segments
:param      timeout:    Enumeration timeout, range:[0, 0xFFFFFFFF]
:return:    dev_num:    device number
            device_info_list:   all device info list
"""

DeviceManager.get_device_number:
"""
:brief      Get device number
:return:    device number
"""

DeviceManager.get_device_info:
"""
:brief      Get all device info
:return:    info_dict:      device info list
"""

DeviceManager.open_device_by_index:
"""
:brief      open device by index
            USB3 device return U3VDevice object
            USB2 device return U2Device object
            GEV  device return GEVDevice object
:param      index:          device index must start from 1
:param      access_mode:    the access of open device
:return:    Device object
"""

DeviceManager.__get_device_class_by_sn:
"""
:brief:     1.find device by sn in self.__device_info_list
            2.return different objects according to device class
:param      sn:      device serial number
:return:    device class
"""

DeviceManager.open_device_by_sn:
"""
:brief      open device by serial number(SN)
            USB3 device return U3VDevice object
            USB2 device return U2Device object
            GEV device return GEVDevice object
:param      sn:             device serial number, type: str
:param      access_mode:    the mode of open device[GxAccessMode]
:return:    Device object
"""

DeviceManager.__get_device_class_by_user_id:
"""
:brief:     1.find device according to sn in self.__device_info_list
            2.return different objects according to device class
:param      user_id:        user ID
:return:    device class
"""

DeviceManager.open_device_by_user_id:
"""
:brief      open device by user defined name
            USB3 device return U3VDevice object
            GEV  device return GEVDevice object
:param      user_id:        user defined name, type:str
:param      access_mode:    the mode of open device[GxAccessMode]
:return:    Device object
"""

DeviceManager.open_device_by_ip:
"""
:brief      open device by device ip address
:param      ip:             device ip address, type:str
:param      access_mode:    the mode of open device[GxAccessMode]
:return:    GEVDevice object
"""

DeviceManager.open_device_by_mac:
"""
:brief      open device by device mac address
:param      mac:            device mac address, type:str
:param      access_mode:    the mode of open device[GxAccessMode]
:return:    GEVDevice object
"""

Feature.get_name:
"""
brief:  Getting Feature Name
return: Success:    feature name
        Failed:     convert feature ID to string
"""

Feature.is_implemented:
"""
brief:  Determining whether the feature is implemented
return: is_implemented
"""

Feature.is_readable:
"""
brief:  Determining whether the feature is readable
return: is_readable
"""

Feature.is_writable:
"""
brief:  Determining whether the feature is writable
return: is_writable
"""

IntFeature.__range_dict:
"""
:brief      Convert GxIntRange to dictionary
:param      int_range:  GxIntRange
:return:    range_dicts
"""

IntFeature.get_range:
"""
:brief      Getting integer range
:return:    integer range dictionary
"""

IntFeature.get:
"""
:brief      Getting integer value
:return:    integer value
"""

IntFeature.set:
"""
:brief      Setting integer value
:param      int_value
:return:    None
"""

FloatFeature.__range_dict:
"""
:brief      Convert GxFloatRange to dictionary
:param      float_range:  GxFloatRange
:return:    range_dicts
"""

FloatFeature.get_range:
"""
:brief      Getting float range
:return:    float range dictionary
"""

FloatFeature.get:
"""
:brief      Getting float value
:return:    float value
"""

FloatFeature.set:
"""
:brief      Setting float value
:param      float_value
:return:    None
"""

EnumFeature.get_range:
"""
:brief      Getting range of Enum feature
:return:    enum_dict:    enum range dictionary
"""

EnumFeature.get:
"""
:brief      Getting value of Enum feature
:return:    enum_value:     enum value
            enum_str:       string for enum description
"""

EnumFeature.set:
"""
:brief      Setting enum value
:param      enum_value
:return:    None
"""

BoolFeature.get:
"""
:brief      Getting bool value
:return:    bool value[bool]
"""

BoolFeature.set:
"""
:brief      Setting bool value
:param      bool_value[bool]
:return:    None
"""

StringFeature.get_string_max_length:
"""
:brief      Getting the maximum length that string can set
:return:    length:     the maximum length that string can set
"""

StringFeature.get:
"""
:brief      Getting string value
:return:    strings
"""

StringFeature.set:
"""
:brief      Setting string value
:param      input_string[string]
:return:    None
"""

BufferFeature.get_buffer_length:
"""
:brief      Getting buffer length
:return:    length:     buffer length
"""

BufferFeature.get_buffer:
"""
:brief      Getting buffer data
:return:    Buffer object

"""

BufferFeature.set_buffer:
"""
:brief      Setting buffer data
:param      buf:    Buffer object
:return:    None
"""

CommandFeature.send_command:
"""
:brief      Sending command
:return:    None
"""

Device.stream_on:
"""
:brief      send start command, camera start transmission image data
:return:    none
"""

Device.stream_off:
"""
:brief      send stop command, camera stop transmission image data
:return:    none
"""

Device.export_config_file:
"""
:brief      Export the current configuration file
:param      file_path:      file path(type: str)
:return:    none
"""

Device.import_config_file:
"""
:brief      Imported configuration file
:param      file_path:  file path(type: str)
:param      verify:     If this value is true, all the imported values will be read out
                        and checked for consistency(type: bool)
:return:    none
"""

Device.close_device:
"""
:brief      close device, close device handle
:return:    None
"""

Device.get_stream_channel_num:
"""
:brief      Get the number of stream channels supported by the current device.
:return:    the number of stream channels
"""

DataStream.set_payload_size:
"""
:brief      set the number of acquisition buffer
:param      buf_num:   the number of acquisition buffer, range:[1, 0xFFFFFFFF]
"""

DataStream.get_image:
"""
:brief          Get an image, get successfully create image class object
:param          timeout:    Acquisition timeout, range:[0, 0xFFFFFFFF]
:return:        image object
"""

DataStream.flush_queue:
"""
:brief      Flush queue
:return:    None
"""

RGBImage.image_improvement:
"""
:brief:     Improve image quality of the object itself
:param      color_correction_param:     color correction param address
                                        (get from Device.ColorCorrectionParam.get_int())
:param      contrast_lut:               contrast lut
:param      gamma_lut:                  gamma lut
:return:    None
"""

RGBImage.saturation:
"""
:brief      Saturation adjustment (RGB24)
:param      factor:                 saturation factor,range(0 ~ 128)
:return:    RGBImage object
"""

RGBImage.sharpen:
"""
:brief       Sharpen adjustment (RGB24)
:param      factor:                 sharpen factor, range(0.1 ~ 5.0)
:return:    None
"""

RGBImage.get_numpy_array:
"""
:brief:     Return data as a numpy.Array type with dimension Image.height * Image.width * 3
:return:    numpy.Array objects
"""

RGBImage.get_image_size:
"""
:brief      Get RGB data size
:return:    size
"""

RawImage.__get_bit_depth:
"""
:brief      Calculate pixel depth based on pixel format
:param      pixel_format
:return:    pixel depth
"""

RawImage.__get_pixel_color_filter:
"""
:brief      Calculate pixel color filter based on pixel format
:param      pixel_format
:return:    pixel color filter
"""

RawImage.__pixel_format_raw16_to_raw8:
"""
:brief      convert raw16 to raw8, the pixel format need convert to 8bit bayer format
:param      pixel_format(10bit, 12bit, 16bit)
:return:    pixel_format(8bit)
"""

RawImage.__raw16_to_raw8:
"""
:brief      convert raw16 to raw8
:param      pixel_bit_depth     pixel bit depth
:param      valid_bits:         data valid digit[DxValidBit]
:return:    RAWImage object
"""

RawImage.__raw8_to_rgb:
"""
:brief      convert raw8 to RGB
:param      raw8_image          RAWImage object, bit depth is 8bit
:param      convert_type:       Bayer convert type, See detail in DxBayerConvertType
:param      pixel_color_filter: pixel color filter, See detail in DxPixelColorFilter
:param      flip:               Output image flip flag
                                True: turn the image upside down
                                False: do not flip
:return:    RAWImage object
"""

RawImage.convert:
"""
:brief      Image format convert
:param      mode:           "RAW8":     convert raw16 RAWImage object to raw8 RAWImage object
                            "RGB":   convert raw8 RAWImage object to RGBImage object
:param      flip:           Output image flip flag
                            True: turn the image upside down
                            False: do not flip
:param      valid_bits:     Data valid digit, See detail in DxValidBit, raw8 don't this param
:param      convert_type:   Bayer convert type, See detail in DxBayerConvertType
:return:    return image object according to mode parameter
"""

RawImage.defective_pixel_correct:
"""
:brief      Auto raw defective pixel correct,Support image from Raw8 to Raw16, the bit number is actual
            bit number, when it is more than 8, the actual bit can be every number between 9 to 16.
            And if image format is packed, you need convert it to Raw16.
            This function should be used in each frame.
:return:    None
"""

RawImage.get_numpy_array:
"""
:brief      Return data as a numpy.Array type with dimension Image.height * Image.width
:return:    numpy.Array objects
"""

RawImage.get_data:
"""
:brief      get Raw data
:return:    raw data[string]
"""

RawImage.save_raw:
"""
:brief      save raw data
:param      file_path:      file path
:return:    None
"""

RawImage.get_status:
"""
:brief      get raw data status
:return:    status
"""

RawImage.get_width:
"""
:brief      get width of raw data
:return:    width
"""

RawImage.get_height:
"""
:brief     get height of raw data
:return:
"""

RawImage.get_pixel_format:
"""
:brief      Get image pixel format
:return:    pixel format
"""

RawImage.get_image_size:
"""
:brief      Get raw data size
:return:    size
"""

RawImage.get_frame_id:
"""
:brief      Get  frame id of raw data
:return:    frame id
"""

RawImage.get_timestamp:
"""
:brief      Get timestamp of raw data
:return:    timestamp
"""

Utility.get_gamma_lut:
"""
:brief      Get gamma lookup table
:param      gamma: Gamma value, range:[0.1, 10.0]
:return:    Gamma lookup table as Buffer object
"""

Utility.get_contrast_lut:
"""
:brief      Get contrast lookup table
:param      contrast: Contrast value, range:[-50, 100]
:return:    Contrast lookup table as Buffer object
"""
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/api/gxipy/gxiapi.py
Here are the method headers with docstring descriptions extracted from the Python file:

DeviceManager.__get_device_info_list:
"""
:brief      Convert GxDeviceBaseInfo and GxDeviceIPInfo to device info list
:param      base_info:  device base info list[GxDeviceBaseInfo]
:param      ip_info:    device ip info list[GxDeviceIPInfo]
:param      num:        device number
:return:    device info list
"""

DeviceManager.__get_ip_info:
"""
:brief      Get the network information
"""

DeviceManager.update_device_list:
"""
:brief      enumerate the same network segment devices
:param      timeout:    Enumeration timeout, range:[0, 0xFFFFFFFF]
:return:    dev_num:    device number
            device_info_list: all device info list
"""

DeviceManager.update_all_device_list:
"""
:brief      Enumerate devices on different network segments
:param      timeout:    Enumeration timeout, range:[0, 0xFFFFFFFF]
:return:    dev_num:    device number
            device_info_list:   all device info list
"""

DeviceManager.get_device_number:
"""
:brief      Get device number
:return:    device number
"""

DeviceManager.get_device_info:
"""
:brief      Get all device info
:return:    info_dict:      device info list
"""

DeviceManager.open_device_by_index:
"""
:brief      open device by index
            USB3 device return U3VDevice object
            USB2 device return U2Device object
            GEV  device return GEVDevice object
:param      index:          device index must start from 1
:param      access_mode:    the access of open device
:return:    Device object
"""

DeviceManager.__get_device_class_by_sn:
"""
:brief:     1.find device by sn in self.__device_info_list
            2.return different objects according to device class
:param      sn:      device serial number
:return:    device class
"""

DeviceManager.open_device_by_sn:
"""
:brief      open device by serial number(SN)
            USB3 device return U3VDevice object
            USB2 device return U2Device object
            GEV device return GEVDevice object
:param      sn:             device serial number, type: str
:param      access_mode:    the mode of open device[GxAccessMode]
:return:    Device object
"""

DeviceManager.__get_device_class_by_user_id:
"""
:brief:     1.find device according to sn in self.__device_info_list
            2.return different objects according to device class
:param      user_id:        user ID
:return:    device class
"""

DeviceManager.open_device_by_user_id:
"""
:brief      open device by user defined name
            USB3 device return U3VDevice object
            GEV  device return GEVDevice object
:param      user_id:        user defined name, type:str
:param      access_mode:    the mode of open device[GxAccessMode]
:return:    Device object
"""

DeviceManager.open_device_by_ip:
"""
:brief      open device by device ip address
:param      ip:             device ip address, type:str
:param      access_mode:    the mode of open device[GxAccessMode]
:return:    GEVDevice object
"""

DeviceManager.open_device_by_mac:
"""
:brief      open device by device mac address
:param      mac:            device mac address, type:str
:param      access_mode:    the mode of open device[GxAccessMode]
:return:    GEVDevice object
"""

Feature.get_name:
"""
brief:  Getting Feature Name
return: Success:    feature name
        Failed:     convert feature ID to string
"""

Feature.is_implemented:
"""
brief:  Determining whether the feature is implemented
return: is_implemented
"""

Feature.is_readable:
"""
brief:  Determining whether the feature is readable
return: is_readable
"""

Feature.is_writable:
"""
brief:  Determining whether the feature is writable
return: is_writable
"""

IntFeature.__range_dict:
"""
:brief      Convert GxIntRange to dictionary
:param      int_range:  GxIntRange
:return:    range_dicts
"""

IntFeature.get_range:
"""
:brief      Getting integer range
:return:    integer range dictionary
"""

IntFeature.get:
"""
:brief      Getting integer value
:return:    integer value
"""

IntFeature.set:
"""
:brief      Setting integer value
:param      int_value
:return:    None
"""

FloatFeature.__range_dict:
"""
:brief      Convert GxFloatRange to dictionary
:param      float_range:  GxFloatRange
:return:    range_dicts
"""

FloatFeature.get_range:
"""
:brief      Getting float range
:return:    float range dictionary
"""

FloatFeature.get:
"""
:brief      Getting float value
:return:    float value
"""

FloatFeature.set:
"""
:brief      Setting float value
:param      float_value
:return:    None
"""

EnumFeature.get_range:
"""
:brief      Getting range of Enum feature
:return:    enum_dict:    enum range dictionary
"""

EnumFeature.get:
"""
:brief      Getting value of Enum feature
:return:    enum_value:     enum value
            enum_str:       string for enum description
"""

EnumFeature.set:
"""
:brief      Setting enum value
:param      enum_value
:return:    None
"""

BoolFeature.get:
"""
:brief      Getting bool value
:return:    bool value[bool]
"""

BoolFeature.set:
"""
:brief      Setting bool value
:param      bool_value[bool]
:return:    None
"""

StringFeature.get_string_max_length:
"""
:brief      Getting the maximum length that string can set
:return:    length:     the maximum length that string can set
"""

StringFeature.get:
"""
:brief      Getting string value
:return:    strings
"""

StringFeature.set:
"""
:brief      Setting string value
:param      input_string[string]
:return:    None
"""

BufferFeature.get_buffer_length:
"""
:brief      Getting buffer length
:return:    length:     buffer length
"""

BufferFeature.get_buffer:
"""
:brief      Getting buffer data
:return:    Buffer object

"""

BufferFeature.set_buffer:
"""
:brief      Setting buffer data
:param      buf:    Buffer object
:return:    None
"""

CommandFeature.send_command:
"""
:brief      Sending command
:return:    None
"""

Device.stream_on:
"""
:brief      send start command, camera start transmission image data
:return:    none
"""

Device.stream_off:
"""
:brief      send stop command, camera stop transmission image data
:return:    none
"""

Device.export_config_file:
"""
:brief      Export the current configuration file
:param      file_path:      file path(type: str)
:return:    none
"""

Device.import_config_file:
"""
:brief      Imported configuration file
:param      file_path:  file path(type: str)
:param      verify:     If this value is true, all the imported values will be read out
                        and checked for consistency(type: bool)
:return:    none
"""

Device.close_device:
"""
:brief      close device, close device handle
:return:    None
"""

Device.get_stream_channel_num:
"""
:brief      Get the number of stream channels supported by the current device.
:return:    the number of stream channels
"""

DataStream.set_payload_size:
"""
:brief      set the number of acquisition buffer
:param      buf_num:   the number of acquisition buffer, range:[1, 0xFFFFFFFF]
"""

DataStream.get_image:
"""
:brief          Get an image, get successfully create image class object
:param          timeout:    Acquisition timeout, range:[0, 0xFFFFFFFF]
:return:        image object
"""

DataStream.flush_queue:
"""
:brief      Flush queue
:return:    None
"""

RGBImage.image_improvement:
"""
:brief:     Improve image quality of the object itself
:param      color_correction_param:     color correction param address
                                        (get from Device.ColorCorrectionParam.get_int())
:param      contrast_lut:               contrast lut
:param      gamma_lut:                  gamma lut
:return:    None
"""

RGBImage.saturation:
"""
:brief      Saturation adjustment (RGB24)
:param      factor:                 saturation factor,range(0 ~ 128)
:return:    RGBImage object
"""

RGBImage.sharpen:
"""
:brief       Sharpen adjustment (RGB24)
:param      factor:                 sharpen factor, range(0.1 ~ 5.0)
:return:    None
"""

RGBImage.get_numpy_array:
"""
:brief:     Return data as a numpy.Array type with dimension Image.height * Image.width * 3
:return:    numpy.Array objects
"""

RGBImage.get_image_size:
"""
:brief      Get RGB data size
:return:    size
"""

RawImage.__get_bit_depth:
"""
:brief      Calculate pixel depth based on pixel format
:param      pixel_format
:return:    pixel depth
"""

RawImage.__get_pixel_color_filter:
"""
:brief      Calculate pixel color filter based on pixel format
:param      pixel_format
:return:    pixel color filter
"""

RawImage.__pixel_format_raw16_to_raw8:
"""
:brief      convert raw16 to raw8, the pixel format need convert to 8bit bayer format
:param      pixel_format(10bit, 12bit, 16bit)
:return:    pixel_format(8bit)
"""

RawImage.__raw16_to_raw8:
"""
:brief      convert raw16 to raw8
:param      pixel_bit_depth     pixel bit depth
:param      valid_bits:         data valid digit[DxValidBit]
:return:    RAWImage object
"""

RawImage.__raw8_to_rgb:
"""
:brief      convert raw8 to RGB
:param      raw8_image          RAWImage object, bit depth is 8bit
:param      convert_type:       Bayer convert type, See detail in DxBayerConvertType
:param      pixel_color_filter: pixel color filter, See detail in DxPixelColorFilter
:param      flip:               Output image flip flag
                                True: turn the image upside down
                                False: do not flip
:return:    RAWImage object
"""

RawImage.convert:
"""
:brief      Image format convert
:param      mode:           "RAW8":     convert raw16 RAWImage object to raw8 RAWImage object
                            "RGB":   convert raw8 RAWImage object to RGBImage object
:param      flip:           Output image flip flag
                            True: turn the image upside down
                            False: do not flip
:param      valid_bits:     Data valid digit, See detail in DxValidBit, raw8 don't this param
:param      convert_type:   Bayer convert type, See detail in DxBayerConvertType
:return:    return image object according to mode parameter
"""

RawImage.defective_pixel_correct:
"""
:brief      Auto raw defective pixel correct,Support image from Raw8 to Raw16, the bit number is actual
            bit number, when it is more than 8, the actual bit can be every number between 9 to 16.
            And if image format is packed, you need convert it to Raw16.
            This function should be used in each frame.
:return:    None
"""

RawImage.get_numpy_array:
"""
:brief      Return data as a numpy.Array type with dimension Image.height * Image.width
:return:    numpy.Array objects
"""

RawImage.get_data:
"""
:brief      get Raw data
:return:    raw data[string]
"""

RawImage.save_raw:
"""
:brief      save raw data
:param      file_path:      file path
:return:    None
"""

RawImage.get_status:
"""
:brief      get raw data status
:return:    status
"""

RawImage.get_width:
"""
:brief      get width of raw data
:return:    width
"""

RawImage.get_height:
"""
:brief     get height of raw data
:return:
"""

RawImage.get_pixel_format:
"""
:brief      Get image pixel format
:return:    pixel format
"""

RawImage.get_image_size:
"""
:brief      Get raw data size
:return:    size
"""

RawImage.get_frame_id:
"""
:brief      Get  frame id of raw data
:return:    frame id
"""

RawImage.get_timestamp:
"""
:brief      Get timestamp of raw data
:return:    timestamp
"""

Utility.get_gamma_lut:
"""
:brief      Get gamma lookup table
:param      gamma: Gamma value, range:[0.1, 10.0]
:return:    Gamma lookup table as Buffer object
"""

Utility.get_contrast_lut:
"""
:brief      Get contrast lookup table
:param      contrast: Contrast value, range:[-50, 100]
:return:    Contrast lookup table as Buffer object
"""
File: ./software/control/gui_motion_only.py
OctopiGUI.__init__(self, *args, **kwargs):
Initializes the OctopiGUI class, sets up the microcontroller, navigation controller, widgets, layout, and connections.

OctopiGUI.closeEvent(self, event):
Handles the closing of the GUI, accepts the event, and homes the navigation controller.
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/api/build/lib/gxipy/__init__.py
Here are the extracted method headers with docstring descriptions from the provided Python file:

No method headers with docstrings were found in the given Python file.

The file contains:
- Import statements from gxipy.gxiapi and gxipy.gxidef
- Definition of __all__ list
- Definition of __version__ string

There are no function or method definitions with docstrings in this particular file.
File: ./software/control/gui_simulation.py
OctopiGUI.__init__(self, *args, **kwargs):
Initializes the OctopiGUI class, setting up the camera, microcontroller, various controllers, widgets, and connections for the GUI.

OctopiGUI.closeEvent(self, event):
Handles the closing of the GUI, stopping live view, homing the navigation controller, closing the camera, and shutting down various components.
File: ./software/control/gui_2cameras_async.py
OctopiGUI.__init__(self, *args, **kwargs):
Initializes the OctopiGUI class, setting up cameras, controllers, widgets, and connections for a microscopy application with tracking and fluorescence capabilities.

OctopiGUI.closeEvent(self, event):
Handles the closing of the application, stopping live controllers, closing cameras, image savers, and display windows.
File: ./software/control/gui_tiscamera_DZK250.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def __init__(self, *args, **kwargs):
    """Initialize the OctopiGUI class. Sets up camera, microcontroller, controllers, widgets, and connections."""

def closeEvent(self, event):
    """Handle closing of the application. Stops live view, homes the stage, closes camera and windows."""
File: ./software/control/gui_tiscamera.py
OctopiGUI.__init__(self, *args, **kwargs):
Initializes the OctopiGUI class, setting up the camera, microcontroller, various controllers, widgets, and connections for the GUI. Includes setup for live imaging, navigation, tracking, and image display.

OctopiGUI.closeEvent(self, event):
Handles the closing of the GUI, stopping live imaging, closing the camera, image saver, image display, and display windows.
File: ./software/control/gui_PDAF_calibration.py
OctopiGUI.__init__(self, is_simulation = False, *args, **kwargs):
Initializes the OctopiGUI class, setting up cameras, controllers, widgets, and connections for a two-camera system with PDAF calibration. Handles both simulation and real hardware modes.

OctopiGUI.closeEvent(self, event):
Handles the closing of the GUI, stopping live controllers, closing cameras, image savers, and display windows for both cameras.
File: ./software/control/gui_PDAF_demo.py
OctopiGUI.__init__(self, is_simulation=False, *args, **kwargs):
Initializes the OctopiGUI class, setting up cameras, microcontroller, controllers, widgets, and connections. Handles both simulation and real hardware modes.

OctopiGUI.closeEvent(self, event):
Handles the closing of the GUI, stopping live controllers, closing cameras, image savers, and display windows.

Internal_States.__init__(self):
Initializes the Internal_States class with default values for width, height, and position.
File: ./software/control/NL5Widget.py
NL5SettingsDialog.__init__(self, nl5):
Initializes the NL5 settings dialog with controls for scan amplitude, offset X, and bypass offset.

NL5SettingsDialog.accept(self):
Applies the settings changes to the NL5 object and saves them.

NL5Widget.__init__(self, nl5):
Initializes the NL5 widget with controls for exposure delay, line speed, FOV X, bypass, and NL5 settings.

NL5Widget.show_settings_dialog(self):
Displays the NL5 settings dialog.

NL5Widget.update_bypass(self, checked):
Updates the bypass setting of the NL5 and enables/disables the start acquisition button.

NL5Widget.update_exposure_delay(self, value):
Updates the exposure delay setting of the NL5.

NL5Widget.update_line_speed(self, value):
Updates the line speed setting of the NL5.

NL5Widget.update_fov_x(self, value):
Updates the FOV X setting of the NL5.
File: ./software/control/gui_toupcam_IMX571.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def __init__(self, is_simulation = False, *args, **kwargs):
    """Initialize the OctopiGUI class. Sets up the camera, microcontroller, controllers, widgets, and connections."""

def closeEvent(self, event):
    """Handle closing of the application. Stops live view, closes camera and microcontroller connections."""
File: ./software/control/gui_usbspectrometer.py
OctopiGUI.__init__(self, is_simulation = False, *args, **kwargs):
"""Initialize the OctopiGUI class.
Loads windows, camera, microcontroller, spectrometer, and various controllers.
Sets up widgets, layouts, and connections between components.
Keywords: GUI, camera, microcontroller, spectrometer, widgets, layout"""

OctopiGUI.closeEvent(self, event):
"""Handle the close event of the GUI.
Stops live view, closes camera and other devices, saves data, and closes windows.
Keywords: close, shutdown, cleanup"""
File: ./software/control/gui_2cameras_sync.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def __init__(self, is_simulation = False, *args, **kwargs):
    """Initialize the OctopiGUI class.
    
    Sets up cameras, microcontrollers, widgets, and connections for the GUI.
    Configures image display windows, navigation controls, camera settings,
    live view controls, and recording functionality.
    
    Args:
        is_simulation (bool): Whether to use simulated hardware
    """

def closeEvent(self, event):
    """Handle closing of the GUI window.
    
    Stops live view, closes cameras and microcontrollers, saves images,
    and performs cleanup before closing.
    
    Args:
        event: The close event
    """
File: ./software/control/core_PDAF.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def register_image_from_camera_1(self,image):
    """Register an image from camera 1 for defocus calculation"""

def register_image_from_camera_2(self,image):
    """Register an image from camera 2 for defocus calculation"""

def calculate_defocus(self):
    """Calculate the defocus using registered images from both cameras"""

def _compute_shift_from_image_pair(self):
    """Compute the shift between two images using phase cross-correlation"""

def close(self):
    """Close the PDAFController"""

def set_NX(self,N):
    """Set the number of X positions"""

def set_NY(self,N):
    """Set the number of Y positions"""

def set_NZ(self,N):
    """Set the number of Z positions"""

def set_Nt(self,N):
    """Set the number of time points"""

def set_deltaX(self,delta):
    """Set the X step size"""

def set_deltaY(self,delta):
    """Set the Y step size"""

def set_deltaZ(self,delta_um):
    """Set the Z step size in micrometers"""

def set_deltat(self,delta):
    """Set the time step size"""

def set_af_flag(self,flag):
    """Set the autofocus flag"""

def set_crop(self,crop_width,height):
    """Set the crop dimensions"""

def set_base_path(self,path):
    """Set the base path for saving data"""

def start_new_experiment(self,experiment_ID):
    """Prepare folder for a new experiment"""

def set_selected_configurations(self, selected_configurations_name):
    """Set the selected configurations for the experiment"""

def run_acquisition(self):
    """Run the full acquisition experiment"""

def _run_multipoint_single(self):
    """Run a single multipoint acquisition"""
File: ./software/drivers and libraries/daheng camera/Galaxy_Linux_Python_1.0.1905.9081/api/build/lib/gxipy/gxidef.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

class GxFrameStatusList:
    """Frame state codes for image processing"""

class GxDeviceClassList:
    """Device type codes for different vision devices"""

class GxAccessMode:
    """Access modes for opening devices"""

class GxAccessStatus:
    """Current access status of devices"""

class GxIPConfigureModeList:
    """IP configuration modes for network devices"""

class GxPixelSizeEntry:
    """Pixel size entries in bits per pixel"""

class GxPixelColorFilterEntry:
    """Pixel color filter patterns"""

class GxPixelFormatEntry:
    """Pixel format entries for different color and bit depths"""

class GxAcquisitionModeEntry:
    """Acquisition modes for image capture"""

class GxTriggerSourceEntry:
    """Trigger source options for image acquisition"""

class GxTriggerActivationEntry:
    """Trigger activation edge types"""

class GxExposureModeEntry:
    """Exposure modes for image capture"""

class GxUserOutputSelectorEntry:
    """User output selector options"""

class GxUserOutputModeEntry:
    """User output mode options"""

class GxGainSelectorEntry:
    """Gain selector options for color channels"""

class GxBlackLevelSelectEntry:
    """Black level selector options for color channels"""

class GxBalanceRatioSelectorEntry:
    """Balance ratio selector options for color channels"""

class GxAALightEnvironmentEntry:
    """Auto algorithm light environment options"""

class GxUserSetEntry:
    """User set options for camera settings"""

class GxAWBLampHouseEntry:
    """Auto white balance lamp house options"""

class GxTestPatternEntry:
    """Test pattern options for image generation"""

class GxTriggerSelectorEntry:
    """Trigger selector options"""

class GxLineSelectorEntry:
    """Line selector options for I/O lines"""

class GxLineModeEntry:
    """Line mode options for I/O lines"""

class GxLineSourceEntry:
    """Line source options for output lines"""

class GxEventSelectorEntry:
    """Event selector options"""

class GxLutSelectorEntry:
    """LUT selector options"""

class GxTransferControlModeEntry:
    """Transfer control mode options"""

class GxTransferOperationModeEntry:
    """Transfer operation mode options"""

class GxTestPatternGeneratorSelectorEntry:
    """Test pattern generator selector options"""

class GxChunkSelectorEntry:
    """Chunk data selector options"""

class GxTimerSelectorEntry:
    """Timer selector options"""

class GxTimerTriggerSourceEntry:
    """Timer trigger source options"""

class GxCounterSelectorEntry:
    """Counter selector options"""

class GxCounterEventSourceEntry:
    """Counter event source options"""

class GxCounterResetSourceEntry:
    """Counter reset source options"""

class GxCounterResetActivationEntry:
    """Counter reset activation options"""

class GxBinningHorizontalModeEntry:
    """Horizontal binning mode options"""

class GxBinningVerticalModeEntry:
    """Vertical binning mode options"""

class GxAcquisitionStatusSelectorEntry:
    """Acquisition status selector options"""

class GxGammaModeEntry:
    """Gamma correction mode options"""

class GxColorTransformationModeEntry:
    """Color transformation mode options"""

class GxColorTransformationValueSelectorEntry:
    """Color transformation value selector options"""

class GxAutoEntry:
    """Auto mode options"""

class GxSwitchEntry:
    """On/Off switch options"""

class GxRegionSendModeEntry:
    """Region send mode options"""

class GxRegionSelectorEntry:
    """Region selector options"""

class DxBayerConvertType:
    """Bayer conversion algorithm options"""

class DxValidBit:
    """Image valid bit options"""

class DxImageMirrorMode:
    """Image mirroring mode options"""
File: ./software/control/serial_peripherals.py
SerialDevice.__init__(self, port=None, VID=None, PID=None, SN=None, baudrate=9600, read_timeout=1, **kwargs):
"""Initialize the serial connection for a device."""

SerialDevice.open_ser(self, SN=None, VID=None, PID=None, baudrate=None, read_timeout=None, **kwargs):
"""Open the serial connection for the device."""

SerialDevice.write_and_check(self, command, expected_response, read_delay=0.1, max_attempts=3, attempt_delay=1, check_prefix=True, print_response=False):
"""Write a command and check the response."""

SerialDevice.write(self, command):
"""Write a command to the serial device."""

SerialDevice.close(self):
"""Close the serial connection."""

XLight.__init__(self, SN, sleep_time_for_wheel=0.25):
"""Initialize the XLight device with a given serial number."""

XLight.set_emission_filter(self, position, extraction=False, validate=True):
"""Set the emission filter wheel position."""

XLight.get_emission_filter(self):
"""Get the current emission filter wheel position."""

XLight.set_dichroic(self, position, extraction=False):
"""Set the dichroic wheel position."""

XLight.get_dichroic(self):
"""Get the current dichroic wheel position."""

XLight.set_disk_position(self, position):
"""Set the spinning disk position."""

XLight.get_disk_position(self):
"""Get the current spinning disk position."""

XLight.set_disk_motor_state(self, state):
"""Set the disk motor state (True for ON, False for OFF)."""

XLight.get_disk_motor_state(self):
"""Get the current disk motor state."""

LDI.__init__(self, SN="00000001"):
"""Initialize the LDI device with a given serial number."""

LDI.run(self):
"""Run the LDI device."""

LDI.set_intensity(self, channel, intensity):
"""Set the intensity for a specific channel."""

LDI.set_shutter(self, channel, state):
"""Set the shutter state for a specific channel."""

LDI.get_shutter_state(self):
"""Get the current shutter state."""

LDI.set_active_channel(self, channel):
"""Set the active channel."""

LDI.set_active_channel_shutter(self, state):
"""Set the shutter state for the active channel."""

SciMicroscopyLEDArray.__init__(self, SN, array_distance=50, turn_on_delay=0.03):
"""Initialize the SciMicroscopy LED Array with a given serial number."""

SciMicroscopyLEDArray.write(self, command):
"""Write a command to the LED Array."""

SciMicroscopyLEDArray.check_about(self):
"""Check the 'about' information of the LED Array."""

SciMicroscopyLEDArray.set_distance(self, array_distance):
"""Set the array distance from the sample."""

SciMicroscopyLEDArray.set_NA(self, NA):
"""Set the numerical aperture."""

SciMicroscopyLEDArray.set_color(self, color):
"""Set the color of the LED Array."""

SciMicroscopyLEDArray.set_brightness(self, brightness):
"""Set the brightness of the LED Array."""

SciMicroscopyLEDArray.turn_on_bf(self):
"""Turn on brightfield illumination."""

SciMicroscopyLEDArray.turn_on_dpc(self, quadrant):
"""Turn on differential phase contrast illumination."""

SciMicroscopyLEDArray.turn_on_df(self):
"""Turn on darkfield illumination."""

SciMicroscopyLEDArray.set_illumination(self, illumination):
"""Set the illumination mode."""

SciMicroscopyLEDArray.clear(self):
"""Clear the current illumination settings."""

SciMicroscopyLEDArray.turn_on_illumination(self):
"""Turn on the set illumination."""

SciMicroscopyLEDArray.turn_off_illumination(self):
"""Turn off the current illumination."""

CellX.__init__(self, SN=""):
"""Initialize the CellX device with a given serial number."""

CellX.turn_on(self, channel):
"""Turn on a specific channel."""

CellX.turn_off(self, channel):
"""Turn off a specific channel."""

CellX.set_laser_power(self, channel, power):
"""Set the laser power for a specific channel."""

CellX.set_modulation(self, channel, modulation):
"""Set the modulation mode for a specific channel."""

CellX.close(self):
"""Close the connection to the CellX device."""

FilterController.__init__(self, SN, _baudrate, _bytesize, _parity, _stopbits):
"""Initialize the Filter Controller with given serial parameters."""

FilterController.send_command(self, cmd):
"""Send a command to the Filter Controller."""

FilterController.send_command_with_reply(self, cmd):
"""Send a command to the Filter Controller and wait for a reply."""

FilterController.get_info(self, cmd):
"""Get information from the Filter Controller."""

FilterController.get_position(self):
"""Get the current position of the filter wheel."""

FilterController.get_index(self):
"""Get the current index of the filter wheel."""

FilterController.move_to_offset(self):
"""Move the filter wheel to the offset position."""

FilterController.move_index_position(self, pos_index):
"""Move the filter wheel to a specific index position."""

FilterController.set_emission_filter(self, position):
"""Set the emission filter to a specific position."""

FilterController.get_emission_filter(self):
"""Get the current emission filter position."""

FilterController.do_homing(self):
"""Initiate the homing procedure for the filter wheel."""

FilterController.wait_homing_finish(self):
"""Wait for the homing procedure to finish."""
File: ./software/control/camera_flir.py
get_value_node(node):
    Retrieves and prints the display name and value of all node types as value nodes.
    A value node is a general node type that allows for the reading and writing of any node type as a string.
    Returns: node name and value, both strings

get_string_node(node):
    Retrieves the display name and value of a string node.
    Returns: Tuple of node name and value

get_integer_node(node):
    Retrieves and prints the display name and value of an integer node.
    Returns: Tuple of node name and value

get_float_node(node):
    Retrieves the name and value of a float node.
    Returns: Tuple of node name and value

get_boolean_node(node):
    Retrieves the display name and value of a Boolean node.
    Returns: Tuple of node name and value

get_command_node(node):
    This function retrieves the name and tooltip of a command
    The tooltip is printed below because command nodes do not have an intelligible value.
    Returns: node name and tooltip as a tuple

get_enumeration_node_and_current_entry(node):
    This function retrieves and prints the display names of an enumeration node
    and its current entry (which is actually housed in another node unto itself).
    Returns: name and symbolic of current entry in enumeration

get_category_node_and_all_features(node):
    This function retrieves and prints out the display name of a category node
    before printing all child nodes. Child nodes that are also category nodes
    are also retrieved recursively
    Returns: Dictionary of category node features

get_device_info(cam):
    Retrieves device information for a camera.
    Returns: Dictionary of device information

get_device_info_full(cam, get_genicam=False):
    Retrieves full device information for a camera, including GenICam features if specified.
    Returns: Dictionary of full device information

retrieve_all_camera_info(get_genicam=False):
    Retrieves information for all connected cameras.
    Returns: List of dictionaries containing camera information

get_sn_by_model(model_name):
    Retrieves the serial number of a camera by its model name.
    Returns: Serial number string or None if not found

Camera.__init__(self, sn=None, is_global_shutter=False, rotate_image_angle=None, flip_image=None, is_color=False):
    Initializes a Camera object with the specified parameters.

Camera.set_callback(self, function):
    Sets the callback function for new image events.

Camera.enable_callback(self):
    Enables the callback for new image events.

Camera.disable_callback(self):
    Disables the callback for new image events.

Camera.open(self, index=0, is_color=None):
    Opens a camera connection with the specified index and color mode.

Camera.open_by_sn(self, sn, is_color=None):
    Opens a camera connection using the specified serial number and color mode.

Camera.close(self):
    Closes the camera connection and releases resources.

Camera.set_exposure_time(self, exposure_time):
    Sets the exposure time for the camera in milliseconds.

Camera.update_camera_exposure_time(self):
    Updates the camera's exposure time based on the current settings.

Camera.set_analog_gain(self, analog_gain):
    Sets the analog gain for the camera.

Camera.get_awb_ratios(self):
    Retrieves the auto white balance ratios for the camera.
    Returns: Tuple of red, green, and blue balance ratios

Camera.set_wb_ratios(self, wb_r=None, wb_g=None, wb_b=None):
    Sets the white balance ratios for the camera.

Camera.set_reverse_x(self, value):
    Sets the reverse X setting for the camera.

Camera.set_reverse_y(self, value):
    Sets the reverse Y setting for the camera.

Camera.start_streaming(self):
    Starts the camera streaming.

Camera.stop_streaming(self):
    Stops the camera streaming.

Camera.set_pixel_format(self, pixel_format, convert_if_not_native=False):
    Sets the pixel format for the camera.

Camera.set_continuous_acquisition(self):
    Sets the camera to continuous acquisition mode.

Camera.set_triggered_acquisition_flir(self, source, activation=None):
    Sets the camera to triggered acquisition mode with the specified source and activation.

Camera.set_software_triggered_acquisition(self):
    Sets the camera to software-triggered acquisition mode.

Camera.set_hardware_triggered_acquisition(self, source='Line2', activation='RisingEdge'):
    Sets the camera to hardware-triggered acquisition mode with the specified source and activation.

Camera.send_trigger(self):
    Sends a software trigger to the camera.

Camera.read_frame(self):
    Reads a frame from the camera.
    Returns: NumPy array containing the image data

Camera.set_ROI(self, offset_x=None, offset_y=None, width=None, height=None):
    Sets the region of interest (ROI) for the camera.

Camera.reset_camera_acquisition_counter(self):
    Resets the camera's acquisition counter.

Camera.set_line3_to_strobe(self):
    Sets Line 3 to strobe mode (not implemented for FLIR cameras).

Camera.set_line3_to_exposure_active(self):
    Sets Line 3 to exposure active mode (not implemented for BlackFly cameras).
File: ./software/control/camera_toupcam.py
def get_sn_by_model(model_name):
    """
    Get the serial number of a connected camera by its model name.
    
    Args:
        model_name (str): The model name of the camera to find
        
    Returns:
        str: The serial number of the matching camera, or None if not found
    """

class Camera(object):

    def open(self,index=0):
        """
        Open and initialize the camera.
        
        Args:
            index (int): Index of the camera to open if multiple are connected
        """

    def set_callback(self,function):
        """
        Set the callback function to be called when a new image is ready.
        
        Args:
            function: The callback function
        """

    def enable_callback(self):
        """Enable the image callback"""

    def disable_callback(self):
        """Disable the image callback"""

    def close(self):
        """Close the camera and release resources"""

    def set_exposure_time(self,exposure_time):
        """
        Set the exposure time of the camera.
        
        Args:
            exposure_time (float): Exposure time in milliseconds
        """

    def set_analog_gain(self,analog_gain):
        """
        Set the analog gain of the camera.
        
        Args:
            analog_gain (float): Analog gain value
        """

    def get_awb_ratios(self):
        """
        Get the auto white balance ratios.
        
        Returns:
            tuple: RGB white balance ratios
        """

    def set_wb_ratios(self, wb_r=None, wb_g=None, wb_b=None):
        """
        Set the white balance ratios.
        
        Args:
            wb_r (float): Red white balance ratio
            wb_g (float): Green white balance ratio  
            wb_b (float): Blue white balance ratio
        """

    def start_streaming(self):
        """Start image streaming from the camera"""

    def stop_streaming(self):
        """Stop image streaming from the camera"""

    def set_pixel_format(self,pixel_format):
        """
        Set the pixel format of the camera.
        
        Args:
            pixel_format (str): Pixel format to set
        """

    def set_data_format(self,data_format):
        """
        Set the data format of the camera.
        
        Args:
            data_format (str): Data format to set ('RGB' or 'RAW')
        """

    def set_resolution(self,width,height):
        """
        Set the resolution of the camera.
        
        Args:
            width (int): Image width in pixels
            height (int): Image height in pixels
        """

    def get_temperature(self):
        """
        Get the current temperature of the camera.
        
        Returns:
            float: Camera temperature in Celsius
        """

    def set_temperature(self,temperature):
        """
        Set the target temperature of the camera.
        
        Args:
            temperature (float): Target temperature in Celsius
        """

    def set_fan_speed(self,speed):
        """
        Set the fan speed of the camera.
        
        Args:
            speed (int): Fan speed value
        """

    def set_continuous_acquisition(self):
        """Set the camera to continuous acquisition mode"""

    def set_software_triggered_acquisition(self):
        """Set the camera to software triggered acquisition mode"""

    def set_hardware_triggered_acquisition(self):
        """Set the camera to hardware triggered acquisition mode"""

    def set_trigger_width_mode(self):
        """Set the camera to trigger width mode"""

    def set_gain_mode(self,mode):
        """
        Set the gain mode of the camera.
        
        Args:
            mode (str): Gain mode to set ('LCG', 'HCG', or 'HDR')
        """

    def send_trigger(self):
        """Send a software trigger to the camera"""

    def stop_exposure(self):
        """Stop the current exposure"""

    def read_frame(self,reset_image_ready_flag=True):
        """
        Read a frame from the camera.
        
        Args:
            reset_image_ready_flag (bool): Whether to reset the image ready flag
            
        Returns:
            numpy.ndarray: The captured image frame
        """

    def set_ROI(self,offset_x=None,offset_y=None,width=None,height=None):
        """
        Set the region of interest (ROI) of the camera.
        
        Args:
            offset_x (int): X offset of ROI
            offset_y (int): Y offset of ROI  
            width (int): Width of ROI
            height (int): Height of ROI
        """

    def reset_camera_acquisition_counter(self):
        """Reset the camera's internal acquisition counter"""

    def set_line3_to_strobe(self):
        """Set line 3 to strobe mode"""

    def set_line3_to_exposure_active(self):
        """Set line 3 to exposure active mode"""

class Camera_Simulation(object):

    def open(self,index=0):
        """
        Open and initialize the simulated camera.
        
        Args:
            index (int): Index of the camera to open if multiple are connected
        """

    def set_callback(self,function):
        """
        Set the callback function to be called when a new image is ready.
        
        Args:
            function: The callback function
        """

    def enable_callback(self):
        """Enable the image callback"""

    def disable_callback(self):
        """Disable the image callback"""

    def close(self):
        """Close the simulated camera"""

    def set_exposure_time(self,exposure_time):
        """
        Set the exposure time of the simulated camera.
        
        Args:
            exposure_time (float): Exposure time in milliseconds
        """

    def set_analog_gain(self,analog_gain):
        """
        Set the analog gain of the simulated camera.
        
        Args:
            analog_gain (float): Analog gain value
        """

    def start_streaming(self):
        """Start image streaming from the simulated camera"""

    def stop_streaming(self):
        """Stop image streaming from the simulated camera"""

    def set_pixel_format(self,pixel_format):
        """
        Set the pixel format of the simulated camera.
        
        Args:
            pixel_format (str): Pixel format to set
        """

    def get_temperature(self):
        """
        Get the current temperature of the simulated camera.
        
        Returns:
            float: Simulated camera temperature (always 0)
        """

    def set_temperature(self,temperature):
        """
        Set the target temperature of the simulated camera.
        
        Args:
            temperature (float): Target temperature in Celsius
        """

    def set_fan_speed(self,speed):
        """
        Set the fan speed of the simulated camera.
        
        Args:
            speed (int): Fan speed value
        """

    def set_continuous_acquisition(self):
        """Set the simulated camera to continuous acquisition mode"""

    def set_software_triggered_acquisition(self):
        """Set the simulated camera to software triggered acquisition mode"""

    def set_hardware_triggered_acquisition(self):
        """Set the simulated camera to hardware triggered acquisition mode"""

    def set_gain_mode(self,mode):
        """
        Set the gain mode of the simulated camera.
        
        Args:
            mode (str): Gain mode to set
        """

    def send_trigger(self):
        """Send a software trigger to the simulated camera"""

    def stop_exposure(self):
        """Stop the current exposure on the simulated camera"""

    def read_frame(self):
        """
        Read a frame from the simulated camera.
        
        Returns:
            numpy.ndarray: The simulated image frame
        """

    def set_ROI(self,offset_x=None,offset_y=None,width=None,height=None):
        """
        Set the region of interest (ROI) of the simulated camera.
        
        Args:
            offset_x (int): X offset of ROI
            offset_y (int): Y offset of ROI
            width (int): Width of ROI
            height (int): Height of ROI
        """
File: ./software/control/core.py
Here are the method headers with docstring descriptions extracted from the Python file:

class ObjectiveStore:
    def __init__(self, objectives_dict = OBJECTIVES, default_objective = DEFAULT_OBJECTIVE):
        """Initialize ObjectiveStore with objectives dictionary and default objective"""

class StreamHandler(QObject):
    def __init__(self,crop_width=Acquisition.CROP_WIDTH,crop_height=Acquisition.CROP_HEIGHT,display_resolution_scaling=1):
        """Initialize StreamHandler with crop dimensions and display scaling"""

    def start_recording(self):
        """Start recording images"""

    def stop_recording(self):
        """Stop recording images"""

    def start_tracking(self):
        """Start tracking"""

    def stop_tracking(self):
        """Stop tracking"""

    def set_display_fps(self,fps):
        """Set display frames per second"""

    def set_save_fps(self,fps):
        """Set save frames per second"""

    def set_crop(self,crop_width,crop_height):
        """Set crop dimensions"""

    def set_display_resolution_scaling(self, display_resolution_scaling):
        """Set display resolution scaling factor"""

    def on_new_frame(self, camera):
        """Handle new frame from camera"""

class ImageSaver(QObject):
    def __init__(self,image_format=Acquisition.IMAGE_FORMAT):
        """Initialize ImageSaver with image format"""

    def process_queue(self):
        """Process queue of images to save"""

    def enqueue(self,image,frame_ID,timestamp):
        """Add image to save queue"""

    def set_base_path(self,path):
        """Set base path for saving images"""

    def set_recording_time_limit(self,time_limit):
        """Set time limit for recording"""

    def start_new_experiment(self,experiment_ID,add_timestamp=True):
        """Start new experiment with ID and optional timestamp"""

    def close(self):
        """Close ImageSaver and stop processing"""

class ImageSaver_Tracking(QObject):
    def __init__(self,base_path,image_format='bmp'):
        """Initialize ImageSaver for tracking with base path and format"""

    def process_queue(self):
        """Process queue of tracking images to save"""

    def enqueue(self,image,frame_counter,postfix):
        """Add tracking image to save queue"""

    def close(self):
        """Close ImageSaver_Tracking and stop processing"""

class ImageDisplay(QObject):
    def __init__(self):
        """Initialize ImageDisplay"""

    def process_queue(self):
        """Process queue of images to display"""

    def enqueue(self,image):
        """Add image to display queue"""

    def emit_directly(self,image):
        """Emit image directly for display"""

    def close(self):
        """Close ImageDisplay and stop processing"""

class Configuration:
    def __init__(self,mode_id=None,name=None,color=None,camera_sn=None,exposure_time=None,analog_gain=None,illumination_source=None,illumination_intensity=None,z_offset=None,pixel_format=None,_pixel_format_options=None,emission_filter_position=None):
        """Initialize Configuration with imaging parameters"""

class LiveController(QObject):
    def __init__(self,camera,microcontroller,configurationManager,parent=None,control_illumination=True,use_internal_timer_for_hardware_trigger=True,for_displacement_measurement=False):
        """Initialize LiveController to manage live imaging"""

    def turn_on_illumination(self):
        """Turn on illumination"""

    def turn_off_illumination(self):
        """Turn off illumination"""

    def set_illumination(self,illumination_source,intensity,update_channel_settings=True):
        """Set illumination source and intensity"""

    def start_live(self):
        """Start live imaging"""

    def stop_live(self):
        """Stop live imaging"""

    def trigger_acquisition(self):
        """Trigger image acquisition"""

    def _start_triggerred_acquisition(self):
        """Start triggered acquisition"""

    def _set_trigger_fps(self,fps_trigger):
        """Set trigger frames per second"""

    def _stop_triggerred_acquisition(self):
        """Stop triggered acquisition"""

    def set_trigger_mode(self,mode):
        """Set trigger mode"""

    def set_trigger_fps(self,fps):
        """Set trigger frames per second"""

    def set_microscope_mode(self,configuration):
        """Set microscope imaging configuration"""

    def get_trigger_mode(self):
        """Get current trigger mode"""

    def on_new_frame(self):
        """Handle new frame event"""

    def set_display_resolution_scaling(self, display_resolution_scaling):
        """Set display resolution scaling factor"""

class NavigationController(QObject):
    def __init__(self,microcontroller, parent=None):
        """Initialize NavigationController to manage stage movement"""

    def set_flag_click_to_move(self, flag):
        """Set flag to enable/disable click-to-move"""

    def get_flag_click_to_move(self):
        """Get click-to-move flag status"""

    def scan_preview_move_from_click(self, click_x, click_y, image_width, image_height, Nx=1, Ny=1, dx_mm=0.9, dy_mm=0.9):
        """Move stage based on click in preview scan image"""

    def move_from_click(self, click_x, click_y, image_width, image_height):
        """Move stage based on click in live image"""

    def move_to_cached_position(self):
        """Move to last cached position"""

    def cache_current_position(self):
        """Cache current stage position"""

    def move_x(self,delta):
        """Move stage in x direction by delta"""

    def move_y(self,delta):
        """Move stage in y direction by delta"""

    def move_z(self,delta):
        """Move stage in z direction by delta"""

    def move_x_to(self,delta):
        """Move stage to absolute x position"""

    def move_y_to(self,delta):
        """Move stage to absolute y position"""

    def move_z_to(self,delta):
        """Move stage to absolute z position"""

    def move_x_usteps(self,usteps):
        """Move stage x by microsteps"""

    def move_y_usteps(self,usteps):
        """Move stage y by microsteps"""

    def move_z_usteps(self,usteps):
        """Move stage z by microsteps"""

    def update_pos(self,microcontroller):
        """Update stage position from microcontroller"""

    def home_x(self):
        """Home x axis"""

    def home_y(self):
        """Home y axis"""

    def home_z(self):
        """Home z axis"""

    def home_theta(self):
        """Home theta axis"""

    def home_xy(self):
        """Home x and y axes"""

    def zero_x(self):
        """Zero x axis position"""

    def zero_y(self):
        """Zero y axis position"""

    def zero_z(self):
        """Zero z axis position"""

    def zero_theta(self):
        """Zero theta axis position"""

    def home(self):
        """Home all axes"""

    def set_x_limit_pos_mm(self,value_mm):
        """Set positive x limit in mm"""

    def set_x_limit_neg_mm(self,value_mm):
        """Set negative x limit in mm"""

    def set_y_limit_pos_mm(self,value_mm):
        """Set positive y limit in mm"""

    def set_y_limit_neg_mm(self,value_mm):
        """Set negative y limit in mm"""

    def set_z_limit_pos_mm(self,value_mm):
        """Set positive z limit in mm"""

    def set_z_limit_neg_mm(self,value_mm):
        """Set negative z limit in mm"""

    def move_to(self,x_mm,y_mm):
        """Move to absolute x,y position in mm"""

    def configure_encoder(self, axis, transitions_per_revolution,flip_direction):
        """Configure encoder for axis"""

    def set_pid_control_enable(self, axis, enable_flag):
        """Enable/disable PID control for axis"""

    def turnoff_axis_pid_control(self):
        """Turn off PID control for all axes"""

    def get_pid_control_flag(self, axis):
        """Get PID control flag for axis"""

    def keep_scan_begin_position(self, x, y):
        """Store scan begin position"""

    def set_axis_PID_arguments(self, axis, pid_p, pid_i, pid_d):
        """Set PID parameters for axis"""

class SlidePositionControlWorker(QObject):
    def __init__(self,slidePositionController,home_x_and_y_separately=False):
        """Initialize worker for slide position control"""

    def wait_till_operation_is_completed(self,timestamp_start, SLIDE_POTISION_SWITCHING_TIMEOUT_LIMIT_S):
        """Wait until stage operation is completed"""

    def move_to_slide_loading_position(self):
        """Move stage to slide loading position"""

    def move_to_slide_scanning_position(self):
        """Move stage to slide scanning position"""

class SlidePositionController(QObject):
    def __init__(self,navigationController,liveController,is_for_wellplate=False):
        """Initialize controller for slide positioning"""

    def move_to_slide_loading_position(self):
        """Move to slide loading position"""

    def move_to_slide_scanning_position(self):
        """Move to slide scanning position"""

    def slot_stop_live(self):
        """Stop live imaging"""

    def slot_resume_live(self):
        """Resume live imaging"""

class AutofocusWorker(QObject):
    def __init__(self,autofocusController):
        """Initialize worker for autofocus"""

    def run(self):
        """Run autofocus"""

    def wait_till_operation_is_completed(self):
        """Wait until stage operation is completed"""

    def run_autofocus(self):
        """Perform autofocus"""

class AutoFocusController(QObject):
    def __init__(self,camera,navigationController,liveController):
        """Initialize controller for autofocus"""

    def set_N(self,N):
        """Set number of z steps"""

    def set_deltaZ(self,deltaZ_um):
        """Set z step size in um"""

    def set_crop(self,crop_width,crop_height):
        """Set crop dimensions for autofocus"""

    def autofocus(self, focus_map_override=False):
        """Perform autofocus"""

    def _on_autofocus_completed(self):
        """Handle autofocus completion"""

    def slot_image_to_display(self,image):
        """Display autofocus image"""

    def wait_till_autofocus_has_completed(self):
        """Wait for autofocus to complete"""

    def set_focus_map_use(self, enable):
        """Enable/disable focus map"""

    def clear_focus_map(self):
        """Clear focus map"""

    def gen_focus_map(self, coord1,coord2,coord3):
        """Generate focus map from 3 coordinates"""

    def add_current_coords_to_focus_map(self):
        """Add current coordinates to focus map"""

class MultiPointWorker(QObject):
    def __init__(self,multiPointController):
        """Initialize worker for multipoint acquisition"""

    def update_stats(self, new_stats):
        """Update detection statistics"""

    def run(self):
        """Run multipoint acquisition"""

    def wait_till_operation_is_completed(self):
        """Wait until stage operation is completed"""

    def run_single_time_point(self):
        """Acquire single timepoint for multipoint"""

class MultiPointController(QObject):
    def __init__(self,camera,navigationController,liveController,autofocusController,configurationManager,usb_spectrometer=None,scanCoordinates=None,parent=None):
        """Initialize controller for multipoint acquisition"""

    def set_NX(self,N):
        """Set number of x positions"""

    def set_NY(self,N):
        """Set number of y positions"""

    def set_NZ(self,N):
        """Set number of z positions"""

    def set_Nt(self,N):
        """Set number of timepoints"""

    def set_deltaX(self,delta):
        """Set x step size"""

    def set_deltaY(self,delta):
        """Set y step size"""

    def set_deltaZ(self,delta_um):
        """Set z step size in um"""

    def set_deltat(self,delta):
        """Set time interval"""

    def set_af_flag(self,flag):
        """Set autofocus flag"""

    def set_reflection_af_flag(self,flag):
        """Set reflection autofocus flag"""

    def set_gen_focus_map_flag(self, flag):
        """Set generate focus map flag"""

    def set_crop(self,crop_width,height):
        """Set crop dimensions"""

    def set_base_path(self,path):
        """Set base path for saving"""

    def start_new_experiment(self,experiment_ID):
        """Start new multipoint experiment"""

    def set_selected_configurations(self, selected_configurations_name):
        """Set selected imaging configurations"""

    def run_acquisition(self, location_list=None):
        """Run multipoint acquisition"""

    def _on_acquisition_completed(self):
        """Handle acquisition completion"""

    def request_abort_aquisition(self):
        """Request to abort acquisition"""

    def slot_detection_stats(self, stats):
        """Handle detection statistics"""

    def slot_image_to_display(self,image):
        """Display image"""

    def slot_image_to_display_tiled_preview(self,image):
        """Display tiled preview image"""

    def slot_spectrum_to_display(self,data):
        """Display spectrum"""

    def slot_image_to_display_multi(self,image,illumination_source):
        """Display multi-channel image"""

    def slot_current_configuration(self,configuration):
        """Handle current configuration change"""

    def slot_register_current_fov(self,x_mm,y_mm):
        """Register current field of view"""

    def slot_napari_layers_update(self, image, i, j, k, channel):
        """Update napari layers"""

    def slot_napari_layers_init(self, image_height, image_width, dtype, rgb):
        """Initialize napari layers"""

    def slot_z_piezo_um(self, displacement_um):
        """Handle z piezo displacement"""

class TrackingController(QObject):
    def __init__(self,camera,microcontroller,navigationController,configurationManager,liveController,autofocusController,imageDisplayWindow):
        """Initialize controller for tracking"""

    def start_tracking(self):
        """Start tracking"""

    def _on_tracking_stopped(self):
        """Handle tracking stopped"""

    def start_new_experiment(self,experiment_ID):
        """Start new tracking experiment"""

    def set_selected_configurations(self, selected_configurations_name):
        """Set selected tracking configurations"""

    def toggle_stage_tracking(self,state):
        """Toggle stage tracking"""

    def toggel_enable_af(self,state):
        """Toggle autofocus during tracking"""

    def toggel_save_images(self,state):
        """Toggle saving images during tracking"""

    def set_base_path(self,path):
        """Set base path for saving tracking data"""

    def stop_tracking(self):
        """Stop tracking"""

    def slot_image_to_display(self,image):
        """
File: ./software/control/gui_volumetric_imaging.py
OctopiGUI.__init__(self, *args, **kwargs):
Initializes the OctopiGUI class, setting up the camera, microcontroller, various controllers, widgets, and connections for the GUI.

OctopiGUI.closeEvent(self, event):
Handles the closing of the GUI, stopping live view, homing the navigation controller, closing the camera, and shutting down various components.
File: ./software/control/core_tracking.py
Here are the extracted method headers with docstring descriptions for indexing:

def __init__(self,microcontroller,navigationController):
    """Initialize TrackingController with microcontroller and navigationController. Sets up trackers and PID controllers for XY and Z tracking."""

def on_new_frame(self,image,frame_ID,timestamp):
    """Process a new camera frame for tracking. Performs XY and Z tracking, calculates motion commands using PID controllers, and sends commands to microcontroller. Handles initialization of trackers and PID controllers on first frame."""

def start_a_new_track(self):
    """Reset tracking frame counter to start a new tracking session."""
File: ./software/control/toupcam_exceptions.py
def signed_to_unsigned(n, num_bits):
    """
    Helper function to do 2s complement conversion on returned error codes.
    Returns function as a string representation in hexadecimal form.
    """

def hresult_checker(exception, *error_names):
    """
    Gets the hresult_checker's actual type,
    raises it again if unmatchable. Can
    supply it with multiple error name
    strings (see hresult_error_lookup)
    to return only if one of these is
    matched and raise otherwise.

    :return: String containing which
    error type it was, if a valid
    error.
    :raise: HRESULTException if unmatchable
    """
File: ./software/control/gui_camera_only.py
OctopiGUI.__init__(self, *args, **kwargs):
Initializes the OctopiGUI class, setting up the camera, microcontroller, configuration manager, stream handler, live controller, image saver, and image display. It also creates and lays out widgets for camera settings, live control, and recording control. Additionally, it sets up connections between various components and displays the image display window.

OctopiGUI.closeEvent(self, event):
Handles the closing of the application, stopping live operations, closing the camera, image saver, image display, and image display window.
File: ./software/control/gui_6060.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def __init__(self, is_simulation = False, *args, **kwargs):
    """Initialize the OctopiGUI class. Sets up the camera, microcontroller, controllers, widgets, and GUI layout."""

def closeEvent(self, event):
    """Handle closing of the application. Stops live view, closes camera and other resources, and homes the stage."""
File: ./software/control/gui_2cameras_daheng_tis.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def __init__(self, *args, **kwargs):
    """Initialize the OctopiGUI class. Sets up cameras, controllers, widgets, and connections for the GUI."""

def closeEvent(self, event):
    """Handle the window close event. Stops live controllers, closes cameras, image savers, displays, and windows."""
File: ./software/control/core_displacement_measurement.py
DisplacementMeasurementController.__init__(self, x_offset = 0, y_offset = 0, x_scaling = 1, y_scaling = 1, N_average=1, N=10000):
Initializes the DisplacementMeasurementController with offset, scaling, averaging, and array length parameters.

DisplacementMeasurementController.update_measurement(self,image):
Processes an input image to calculate displacement measurements, updates internal arrays, and emits signals with plot data and readings.

DisplacementMeasurementController.update_settings(self,x_offset,y_offset,x_scaling,y_scaling,N_average,N):
Updates the controller's settings for offset, scaling, averaging, and array length.
File: ./software/control/core_volumetric_imaging.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

class StreamHandler(QObject):
    """Handles image streaming, processing, and distribution."""

    def start_recording(self):
        """Starts recording images."""

    def stop_recording(self):
        """Stops recording images."""

    def start_tracking(self):
        """Starts tracking objects in images."""

    def stop_tracking(self):
        """Stops tracking objects in images."""

    def set_display_fps(self,fps):
        """Sets the display frames per second."""

    def set_save_fps(self,fps):
        """Sets the save frames per second."""

    def set_crop(self,crop_width,height):
        """Sets the crop dimensions for images."""

    def set_display_resolution_scaling(self, display_resolution_scaling):
        """Sets the display resolution scaling factor."""

    def on_new_frame(self, camera):
        """Processes a new frame from the camera."""

class ImageArrayDisplayWindow(QMainWindow):
    """Displays an array of images in a grid layout."""

    def display_image(self,image,i):
        """Displays an image in the specified grid position."""
File: ./software/control/widgets.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

class WrapperWindow(QMainWindow):
    def __init__(self, content_widget, *args, **kwargs):
        """Initialize a wrapper window containing the given content widget."""

    def closeEvent(self, event):
        """Handle close event by hiding the window instead of closing."""

    def closeForReal(self, event):
        """Actually close the window."""

class CollapsibleGroupBox(QGroupBox):
    def __init__(self, title):
        """Initialize a collapsible group box with the given title."""

    def toggle_content(self,state):
        """Toggle visibility of the content based on the given state."""

class ConfigEditorForAcquisitions(QDialog):
    def __init__(self, configManager, only_z_offset=True):
        """Initialize config editor for acquisitions."""

    def init_ui(self, only_z_offset=None):
        """Initialize the UI components."""

    def save_config(self):
        """Save the current configuration."""

    def save_to_file(self):
        """Save the current configuration to a file."""

    def load_config_from_file(self,only_z_offset=None):
        """Load configuration from a file."""

class ConfigEditor(QDialog):
    def __init__(self, config):
        """Initialize config editor."""

    def init_ui(self):
        """Initialize the UI components."""

    def save_config(self):
        """Save the current configuration."""

    def save_to_file(self):
        """Save the current configuration to a file."""

    def load_config_from_file(self):
        """Load configuration from a file."""

class ConfigEditorBackwardsCompatible(ConfigEditor):
    def __init__(self, config, original_filepath, main_window):
        """Initialize backwards compatible config editor."""

    def apply_and_exit(self):
        """Apply changes and exit the editor."""

class SpinningDiskConfocalWidget(QWidget):
    def __init__(self, xlight, config_manager=None):
        """Initialize spinning disk confocal widget."""

    def init_ui(self):
        """Initialize the UI components."""

    def disable_all_buttons(self):
        """Disable all buttons in the widget."""

    def enable_all_buttons(self):
        """Enable all buttons in the widget."""

    def toggle_disk_position(self):
        """Toggle the disk position between confocal and widefield."""

    def toggle_motor(self):
        """Toggle the disk motor on/off."""

    def set_emission_filter(self, index):
        """Set the emission filter to the selected position."""

    def set_dichroic(self, index):
        """Set the dichroic to the selected position."""

class ObjectivesWidget(QWidget):
    def __init__(self, objective_store):
        """Initialize objectives widget."""

    def init_ui(self):
        """Initialize the UI components."""

    def display_objective(self, index):
        """Display the selected objective."""

class FocusMapWidget(QWidget):
    def __init__(self, autofocusController, *args, **kwargs):
        """Initialize focus map widget."""

    def init_ui(self):
        """Initialize the UI components."""

    def disable_all_buttons(self):
        """Disable all buttons in the widget."""

    def enable_all_buttons(self):
        """Enable all buttons in the widget."""

    def clear_focusmap(self):
        """Clear the focus map."""

    def update_focusmap_display(self):
        """Update the focus map display."""

    def enable_focusmap(self):
        """Enable or disable the focus map."""

    def add_to_focusmap(self):
        """Add current coordinates to the focus map."""

class CameraSettingsWidget(QFrame):
    def __init__(self, camera, include_gain_exposure_time = False, include_camera_temperature_setting = False, include_camera_auto_wb_setting = False, main=None, *args, **kwargs):
        """Initialize camera settings widget."""

    def add_components(self,include_gain_exposure_time,include_camera_temperature_setting,include_camera_auto_wb_setting):
        """Add UI components to the widget."""

    def toggle_auto_wb(self,pressed):
        """Toggle auto white balance."""

    def set_exposure_time(self,exposure_time):
        """Set the exposure time."""

    def set_analog_gain(self,analog_gain):
        """Set the analog gain."""

    def set_Width(self):
        """Set the ROI width."""

    def set_Height(self):
        """Set the ROI height."""

    def set_ROI_offset(self):
        """Set the ROI offset."""

    def set_temperature(self):
        """Set the camera temperature."""

    def update_measured_temperature(self,temperature):
        """Update the displayed measured temperature."""

    def change_full_res(self, index):
        """Change the full resolution."""

class LiveControlWidget(QFrame):
    def __init__(self, streamHandler, liveController, configurationManager=None, show_trigger_options=True, show_display_options=True, show_autolevel = False, autolevel=False, main=None, *args, **kwargs):
        """Initialize live control widget."""

    def add_components(self,show_trigger_options,show_display_options,show_autolevel,autolevel):
        """Add UI components to the widget."""

    def toggle_live(self,pressed):
        """Toggle live mode."""

    def update_camera_settings(self):
        """Update camera settings."""

    def update_microscope_mode_by_name(self,current_microscope_mode_name):
        """Update microscope mode based on name."""

    def update_trigger_mode(self):
        """Update trigger mode."""

    def update_config_exposure_time(self,new_value):
        """Update exposure time in configuration."""

    def update_config_analog_gain(self,new_value):
        """Update analog gain in configuration."""

    def update_config_illumination_intensity(self,new_value):
        """Update illumination intensity in configuration."""

    def set_microscope_mode(self,config):
        """Set microscope mode."""

    def set_trigger_mode(self,trigger_mode):
        """Set trigger mode."""

class PiezoWidget(QFrame):
    def __init__(self, navigationController, *args, **kwargs):
        """Initialize piezo widget."""

    def add_components(self):
        """Add UI components to the widget."""

    def update_spinBox_from_slider(self, value):
        """Update spin box value from slider."""

    def update_slider_from_spinBox(self, value):
        """Update slider value from spin box."""

    def adjust_position(self, up):
        """Adjust piezo position up or down."""

    def home(self):
        """Home the piezo."""

    def update_displacement_um_display(self, displacement):
        """Update displayed displacement."""

class RecordingWidget(QFrame):
    def __init__(self, streamHandler, imageSaver, main=None, *args, **kwargs):
        """Initialize recording widget."""

    def add_components(self):
        """Add UI components to the widget."""

    def set_saving_dir(self):
        """Set saving directory."""

    def toggle_recording(self,pressed):
        """Toggle recording on/off."""

    def stop_recording(self):
        """Stop recording."""

class NavigationWidget(QFrame):
    def __init__(self, navigationController, slidePositionController=None, main=None, widget_configuration = 'full', *args, **kwargs):
        """Initialize navigation widget."""

    def add_components(self):
        """Add UI components to the widget."""

    def toggle_navigation_controls(self, started):
        """Toggle navigation controls."""

    def setEnabled_all(self, enabled):
        """Enable or disable all controls."""

    def move_x_forward(self):
        """Move X axis forward."""

    def move_x_backward(self):
        """Move X axis backward."""

    def move_y_forward(self):
        """Move Y axis forward."""

    def move_y_backward(self):
        """Move Y axis backward."""

    def move_z_forward(self):
        """Move Z axis forward."""

    def move_z_backward(self):
        """Move Z axis backward."""

    def set_deltaX(self,value):
        """Set X axis delta."""

    def set_deltaY(self,value):
        """Set Y axis delta."""

    def set_deltaZ(self,value):
        """Set Z axis delta."""

    def home_x(self):
        """Home X axis."""

    def home_y(self):
        """Home Y axis."""

    def home_z(self):
        """Home Z axis."""

    def zero_x(self):
        """Zero X axis."""

    def zero_y(self):
        """Zero Y axis."""

    def zero_z(self):
        """Zero Z axis."""

    def slot_slide_loading_position_reached(self):
        """Handle slide reaching loading position."""

    def slot_slide_scanning_position_reached(self):
        """Handle slide reaching scanning position."""

    def switch_position(self):
        """Switch between loading and scanning positions."""

class DACControWidget(QFrame):
    def __init__(self, microcontroller ,*args, **kwargs):
        """Initialize DAC control widget."""

    def add_components(self):
        """Add UI components to the widget."""

    def set_DAC0(self,value):
        """Set DAC0 value."""

    def set_DAC1(self,value):
        """Set DAC1 value."""

class AutoFocusWidget(QFrame):
    def __init__(self, autofocusController, main=None, *args, **kwargs):
        """Initialize autofocus widget."""

    def add_components(self):
        """Add UI components to the widget."""

    def set_deltaZ(self,value):
        """Set Z axis delta for autofocus."""

    def autofocus_is_finished(self):
        """Handle autofocus completion."""

class FilterControllerWidget(QFrame):
    def __init__(self, filterController, liveController, main=None, *args, **kwargs):
        """Initialize filter controller widget."""

    def add_components(self):
        """Add UI components to the widget."""

    def on_selection_change(self, index):
        """Handle filter selection change."""

    def disable_movement_by_switching_channels(self, state):
        """Enable/disable filter movement when switching channels."""

class StatsDisplayWidget(QFrame):
    def __init__(self, *args, **kwargs):
        """Initialize stats display widget."""

    def initUI(self):
        """Initialize the UI components."""

    def display_stats(self, stats):
        """Display statistics."""

class MultiPointWidget(QFrame):
    def __init__(self, multipointController, configurationManager = None, main=None, *args, **kwargs):
        """Initialize multi-point acquisition widget."""

    def add_components(self):
        """Add UI components to the widget."""

    def set_deltaX(self,value):
        """Set X axis delta."""

    def set_deltaY(self,value):
        """Set Y axis delta."""

    def set_deltaZ(self,value):
        """Set Z axis delta."""

    def set_saving_dir(self):
        """Set saving directory."""

    def set_well_selected(self, selected):
        """Set well selection status."""

    def emit_selected_channels(self):
        """Emit selected channels."""

    def toggle_acquisition(self,pressed):
        """Toggle acquisition on/off."""

    def acquisition_is_finished(self):
        """Handle acquisition completion."""

    def setEnabled_all(self,enabled,exclude_btn_startAcquisition=True):
        """Enable or disable all controls."""

    def disable_the_start_aquisition_button(self):
        """Disable start acquisition button."""

    def enable_the_start_aquisition_button(self):
        """Enable start acquisition button."""

class MultiPointWidget2(QFrame):
    def __init__(self, navigationController, navigationViewer, multipointController, configurationManager = None, main=None, scanCoordinates=None, *args, **kwargs):
        """Initialize enhanced multi-point acquisition widget."""

    def add_components(self):
        """Add UI components to the widget."""

    def set_deltaX(self,value):
        """Set X axis delta."""

    def set_deltaY(self,value):
        """Set Y axis delta."""

    def set_deltaZ(self,value):
        """Set Z axis delta."""

    def set_saving_dir(self):
        """Set saving directory."""

    def emit_selected_channels(self):
        """Emit selected channels."""

    def toggle_acquisition(self,pressed):
        """Toggle acquisition on/off."""

    def load_last_used_locations(self):
        """Load previously used locations."""

    def acquisition_is_finished(self):
        """Handle acquisition completion."""

    def setEnabled_all(self,enabled,exclude_btn_startAcquisition=True):
        """Enable or disable all controls."""

    def disable_the_start_aquisition_button(self):
        """Disable start acquisition button."""

    def enable_the_start_aquisition_button(self):
        """Enable start acquisition button."""

    def add_location(self):
        """Add current location to list."""

    def create_point_id(self):
        """Create a new point ID."""

    def remove_location(self):
        """Remove selected location from list."""

    def next(self):
        """Move to next location."""

    def previous(self):
        """Move to previous location."""

    def clear(self):
        """Clear all locations."""

    def clear_only_location_list(self):
        """Clear only the location list."""

    def go_to(self,index):
        """Go to selected location."""

    def cell_was_clicked(self,row,column):
        """Handle cell click in location table."""

    def cell_was_changed(self,row,column):
        """Handle cell change in location table."""

    def keyPressEvent(self, event):
        """Handle key press events."""

    def _update_z(self,index,z_mm):
        """Update Z position for a location."""

    def export_location_list(self):
        """Export location list to CSV."""

    def import_location_list(self):
        """Import location list from CSV."""

class StitcherWidget(QFrame):
    def __init__(self, configurationManager, *args, **kwargs):
        """Initialize stitcher widget."""

    def onRegistrationCheck(self, checked):
        """Handle registration checkbox state change."""

    def updateRegistrationChannels(self, selected_channels):
        """Update registration channel options."""

    def gettingFlatfields(self):
        """Handle flatfield calculation start."""

    def startingStitching(self):
        """Handle stitching start."""

    def updateProgressBar(self, value, total):
        """Update progress bar."""

    def startingSaving(self):
        """Handle saving start."""

    def finishedSaving(self, output_path, dtype):
        """Handle saving completion."""

    def viewOutputNapari(self):
        """View output in Napari."""

class NapariLiveWidget(QWidget):
    def __init__(self, configurationManager, liveControlWidget, parent=None):
        """Initialize Napari live widget."""

    def initNapariViewer(self):
        """Initialize Napari viewer."""

    def initLiveLayer(self, channel, image_height, image_width, image_dtype, rgb=False):
        """Initialize live layer in Napari."""

    def updateLiveLayer(self, image, from_autofocus=False):
        """Update live layer in Napari."""

    def onDoubleClick(self, layer, event):
        """Handle double-click events in Napari."""

    def signalContrastLimits(self, event):
        """Signal contrast limit changes."""

    def saveContrastLimits(self, layer_name, min_val, max_val):
        """Save contrast limits for a layer."""

    def getContrastLimits
File: ./software/control/multipoint_custom_script_entry.py
multipoint_custom_script_entry(multiPointWorker, time_point, current_path, coordinate_id, coordiante_name, i, j):
    """
    Custom script entry point for multipoint acquisition.
    Handles autofocus, z-stacking, image acquisition, and saving for multiple configurations.
    Manages hardware control, image processing, and data logging.
    Supports both contrast-based and laser autofocus methods.
    Handles different imaging modes including brightfield and fluorescence.
    Manages USB spectrometer data acquisition if available.
    Supports abort functionality and coordinates logging.
    """
File: ./software/control/gui_hcs.py
Here are the method headers with docstring descriptions extracted from the Python file:

def __init__(self, is_simulation = False, *args, **kwargs):
    """Initialize the OctopiGUI class. Sets up the camera, microcontroller, controllers, widgets, and UI layout."""

def openLedMatrixSettings(self):
    """Open the LED matrix settings dialog if LED array is supported."""

def onTabChanged(self, index):
    """Handle tab changes in the record tab widget. Updates well selector visibility and emits selected channels."""

def toggleWellSelector(self, close):
    """Toggle visibility of the well selector dock widget."""

def toggleAcquisitionStart(self, acquisition_started):
    """Enable/disable record tabs and well selector based on acquisition state."""

def closeEvent(self, event):
    """Handle application close event. Caches position, moves objective, stops streaming, closes devices and windows."""
File: ./software/control/_def.py
Here are the method headers with docstring descriptions extracted from the Python file:

def conf_attribute_reader(string_value):
    """
    :brief: standardized way for reading config entries
    that are strings, in priority order
    None -> bool -> dict/list (via json) -> int -> float -> string
    REMEMBER TO ENCLOSE PROPERTY NAMES IN LISTS/DICTS IN
    DOUBLE QUOTES
    """

def populate_class_from_dict(myclass, options):
    """
    :brief: helper function to establish a compatibility
        layer between new way of storing config and current
        way of accessing it. assumes all class attributes are
        all-uppercase, and pattern-matches attributes in
        priority order dict/list (json) -> -> int -> float-> string
    REMEMBER TO ENCLOSE PROPERTY NAMES IN LISTS IN DOUBLE QUOTES
    """
File: ./software/control/core_usbspectrometer.py
SpectrumStreamHandler.__init__():
Initializes the SpectrumStreamHandler object with default values for FPS, timestamps, and recording flags.

SpectrumStreamHandler.start_recording():
Sets the save_spectrum_flag to True, enabling spectrum recording.

SpectrumStreamHandler.stop_recording():
Sets the save_spectrum_flag to False, disabling spectrum recording.

SpectrumStreamHandler.set_display_fps(fps):
Sets the display frames per second (FPS) for the spectrum.

SpectrumStreamHandler.set_save_fps(fps):
Sets the save frames per second (FPS) for the spectrum.

SpectrumStreamHandler.on_new_measurement(data):
Handles new spectrum measurements, emits signals for display and recording, and calculates real FPS.

SpectrumSaver.__init__():
Initializes the SpectrumSaver object with default values for paths, experiment ID, and queue settings.

SpectrumSaver.process_queue():
Processes the queue of spectrum data, saving it to files in organized folders.

SpectrumSaver.enqueue(data):
Adds spectrum data to the queue for processing and saving.

SpectrumSaver.set_base_path(path):
Sets the base path for saving spectrum data.

SpectrumSaver.set_recording_time_limit(time_limit):
Sets the time limit for recording spectrum data.

SpectrumSaver.start_new_experiment(experiment_ID, add_timestamp=True):
Starts a new experiment with a given ID and optional timestamp, creating necessary folders.

SpectrumSaver.close():
Closes the SpectrumSaver, joining the queue and stopping the processing thread.
File: ./software/control/gui_platereader.py
OctopiGUI.__init__(self, is_simulation = False, *args, **kwargs):
Initializes the OctopiGUI class, setting up the camera, microcontroller, various controllers, widgets, and connections. Handles both simulation and real hardware modes.

OctopiGUI.closeEvent(self, event):
Handles the closing of the application, stopping live view, closing the camera, image saver, display window, and microcontroller.
File: ./software/control/utils.py
def crop_image(image, crop_width, crop_height):
"""Crops an image to specified width and height from the center. Returns the cropped image."""

def calculate_focus_measure(image, method='LAPE'):
"""Calculates the focus measure of an image using specified method (LAPE or GLVA). Returns the focus measure value."""

def unsigned_to_signed(unsigned_array, N):
"""Converts an unsigned array to a signed integer. Returns the signed integer value."""

def rotate_and_flip_image(image, rotate_image_angle, flip_image):
"""Rotates and/or flips an image based on specified angle and flip direction. Returns the transformed image."""

def generate_dpc(im_left, im_right):
"""Generates a Differential Phase Contrast (DPC) image from left and right images. Returns the DPC image."""

def colorize_mask(mask):
"""Colorizes a binary mask using a color map. Returns the colorized mask."""

def colorize_mask_get_counts(mask):
"""Colorizes a binary mask and counts the number of objects. Returns the colorized mask and object count."""

def overlay_mask_dpc(color_mask, im_dpc):
"""Overlays a colored mask on a DPC image. Returns the overlaid image."""

def centerCrop(image, crop_sz):
"""Crops an image from the center to a specified size. Returns the cropped image."""

def interpolate_plane(triple1, triple2, triple3, point):
"""Linearly interpolates a z-value on a plane defined by three points. Returns the interpolated z-value."""
File: ./software/control/spectrometer_oceanoptics.py
Spectrometer.__init__(self, sn=None): Initialize a Spectrometer object with an optional serial number.

Spectrometer.set_integration_time_ms(self, integration_time_ms): Set the integration time in milliseconds for the spectrometer.

Spectrometer.read_spectrum(self, correct_dark_counts=False, correct_nonlinearity=False): Read the spectrum from the spectrometer with optional dark count and nonlinearity corrections.

Spectrometer.set_callback(self, function): Set a callback function to be called with new spectrum data.

Spectrometer.start_streaming(self): Start streaming spectrum data.

Spectrometer.pause_streaming(self): Pause the streaming of spectrum data.

Spectrometer.resume_streaming(self): Resume the streaming of spectrum data.

Spectrometer.stream(self): Internal method to continuously stream spectrum data.

Spectrometer.close(self): Close the spectrometer and stop streaming.

Spectrometer_Simulation.__init__(self, sn=None): Initialize a simulated Spectrometer object.

Spectrometer_Simulation.set_integration_time_us(self, integration_time_us): Simulate setting the integration time in microseconds.

Spectrometer_Simulation.read_spectrum(self, correct_dark_counts=False, correct_nonlinearity=False): Generate a simulated spectrum.

Spectrometer_Simulation.set_callback(self, function): Set a callback function for simulated spectrum data.

Spectrometer_Simulation.start_streaming(self): Start streaming simulated spectrum data.

Spectrometer_Simulation.pause_streaming(self): Pause the streaming of simulated spectrum data.

Spectrometer_Simulation.resume_streaming(self): Resume the streaming of simulated spectrum data.

Spectrometer_Simulation.stream(self): Internal method to continuously stream simulated spectrum data.

Spectrometer_Simulation.close(self): Stop streaming simulated spectrum data.
File: ./software/control/microcontroller2.py
class Microcontroller2:
    def __init__(self):
        """Initialize Microcontroller2 object, connect to Teensy, set up serial communication"""

    def close(self):
        """Close the serial connection"""

    def analog_write_DAC8050x(self, dac, value):
        """Write analog value to specified DAC"""

    def set_camera_trigger_frequency(self, frequency):
        """Set the camera trigger frequency"""

    def start_camera_trigger(self):
        """Start camera triggering"""

    def stop_camera_trigger(self):
        """Stop camera triggering"""

    def send_command(self, command):
        """Send a command to the microcontroller"""

    def read_received_packet(self):
        """Read and process received packets from the microcontroller"""

    def is_busy(self):
        """Check if the microcontroller is currently executing a command"""

    def set_callback(self, function):
        """Set a callback function for new packet reception"""

class Microcontroller2_Simulation:
    def __init__(self, parent=None):
        """Initialize simulated Microcontroller2 object"""

    def close(self):
        """Close the simulated connection"""

    def analog_write_DAC8050x(self, dac, value):
        """Simulate writing analog value to specified DAC"""

    def set_camera_trigger_frequency(self, frequency):
        """Simulate setting the camera trigger frequency"""

    def start_camera_trigger(self):
        """Simulate starting camera triggering"""

    def stop_camera_trigger(self):
        """Simulate stopping camera triggering"""

    def read_received_packet(self):
        """Simulate reading and processing received packets"""

    def set_callback(self, function):
        """Set a callback function for simulated new packet reception"""

    def is_busy(self):
        """Check if the simulated microcontroller is currently executing a command"""

    def send_command(self, command):
        """Simulate sending a command to the microcontroller"""
File: ./software/control/camera.py
get_sn_by_model(model_name): Retrieves the serial number of a connected device with the specified model name.

Camera.__init__(self, sn=None, is_global_shutter=False, rotate_image_angle=None, flip_image=None): Initializes a Camera object with optional parameters for serial number, shutter type, rotation angle, and image flipping.

Camera.open(self, index=0): Opens a connection to the camera device.

Camera.set_callback(self, function): Sets an external callback function for new image events.

Camera.enable_callback(self): Enables the callback functionality for the camera.

Camera.disable_callback(self): Disables the callback functionality for the camera.

Camera.open_by_sn(self, sn): Opens a connection to the camera device using a specific serial number.

Camera.close(self): Closes the connection to the camera device and resets related parameters.

Camera.set_exposure_time(self, exposure_time): Sets the exposure time for the camera.

Camera.update_camera_exposure_time(self): Updates the camera's exposure time based on current settings.

Camera.set_analog_gain(self, analog_gain): Sets the analog gain for the camera.

Camera.get_awb_ratios(self): Retrieves the auto white balance ratios for the camera.

Camera.set_wb_ratios(self, wb_r=None, wb_g=None, wb_b=None): Sets the white balance ratios for the camera.

Camera.set_balance_white_auto(self, value): Sets the auto white balance mode for the camera.

Camera.get_balance_white_auto(self): Retrieves the current auto white balance mode of the camera.

Camera.get_is_color(self): Returns whether the camera is a color camera.

Camera.set_reverse_x(self, value): Sets the horizontal flip for the camera image.

Camera.set_reverse_y(self, value): Sets the vertical flip for the camera image.

Camera.start_streaming(self): Starts the camera's streaming mode.

Camera.stop_streaming(self): Stops the camera's streaming mode.

Camera.set_pixel_format(self, pixel_format): Sets the pixel format for the camera.

Camera.set_continuous_acquisition(self): Sets the camera to continuous acquisition mode.

Camera.set_software_triggered_acquisition(self): Sets the camera to software-triggered acquisition mode.

Camera.set_hardware_triggered_acquisition(self): Sets the camera to hardware-triggered acquisition mode.

Camera.send_trigger(self): Sends a software trigger to the camera.

Camera.read_frame(self): Reads and returns the current frame from the camera.

Camera.set_ROI(self, offset_x=None, offset_y=None, width=None, height=None): Sets the Region of Interest (ROI) for the camera.

Camera.reset_camera_acquisition_counter(self): Resets the camera's acquisition counter.

Camera.set_line3_to_strobe(self): Configures Line 3 of the camera to strobe mode.

Camera.set_line3_to_exposure_active(self): Configures Line 3 of the camera to exposure active mode.

Camera_Simulation.__init__(self, sn=None, is_global_shutter=False, rotate_image_angle=None, flip_image=None): Initializes a Camera_Simulation object with similar parameters as the Camera class.
File: ./software/control/NL5.py
NL5.__init__()
Initializes the NL5 object, sets up the RCM API, and loads settings.

NL5.set_scan_amplitude(amplitude)
Sets the scan amplitude for the device.

NL5.set_offset_x(offset_x)
Sets the X-axis offset for scanning.

NL5.start_acquisition()
Starts the acquisition process.

NL5.start_continuous_acquisition()
Starts continuous acquisition.

NL5.stop_continuous_acquisition()
Stops the continuous acquisition process.

NL5.set_bypass(enabled)
Enables or disables the bypass mode.

NL5.set_active_channel(channel)
Sets the active laser channel.

NL5.set_laser_power(channel, power)
Sets the power for a specific laser channel.

NL5.set_bypass_offset(offset)
Sets the bypass offset value.

NL5.set_line_speed(speed, save_setting=False)
Sets the line speed and optionally saves the setting.

NL5.set_fov_x(fov_x)
Sets the X-axis field of view and saves the setting.

NL5.set_exposure_delay(exposure_delay_ms)
Sets the exposure delay in milliseconds.

NL5.load_settings()
Loads settings from a JSON file or sets default values.

NL5.save_settings()
Saves current settings to a JSON file.

NL5_Simulation.__init__()
Initializes the NL5_Simulation object and loads settings.

NL5_Simulation.set_scan_amplitude(amplitude)
Simulates setting the scan amplitude.

NL5_Simulation.set_offset_x(offset_x)
Simulates setting the X-axis offset.

NL5_Simulation.start_acquisition()
Simulates starting the acquisition process.

NL5_Simulation.start_continuous_acquisition()
Simulates starting continuous acquisition.

NL5_Simulation.stop_continuous_acquisition()
Simulates stopping continuous acquisition.

NL5_Simulation.set_bypass(enabled)
Simulates setting the bypass mode.

NL5_Simulation.set_active_channel(channel)
Simulates setting the active channel.

NL5_Simulation.set_laser_power(channel, power)
Simulates setting laser power for a channel.

NL5_Simulation.set_bypass_offset(offset)
Simulates setting the bypass offset.

NL5_Simulation.set_line_speed(speed, save_setting=False)
Simulates setting the line speed and optionally saves the setting.

NL5_Simulation.set_fov_x(fov_x)
Simulates setting the X-axis field of view and saves the setting.

NL5_Simulation.set_exposure_delay(exposure_delay_ms)
Simulates setting the exposure delay.

NL5_Simulation.load_settings()
Loads settings from a JSON file or sets default values for simulation.

NL5_Simulation.save_settings()
Saves current simulation settings to a JSON file.
File: ./software/control/core_platereader.py
PlateReadingWorker.run():
Runs the plate reading acquisition process for multiple time points.

PlateReadingWorker.wait_till_operation_is_completed():
Waits until the microcontroller has completed its current operation.

PlateReadingWorker.run_single_time_point():
Executes the acquisition process for a single time point, including moving through columns and rows, autofocusing, and capturing images.

PlateReadingController.__init__(self, camera, plateReaderNavigationController, liveController, autofocusController, configurationManager):
Initializes the PlateReadingController with necessary components and default settings.

PlateReadingController.set_NZ(self, N):
Sets the number of Z-stack layers.

PlateReadingController.set_Nt(self, N):
Sets the number of time points.

PlateReadingController.set_deltaZ(self, delta_um):
Sets the Z-step size in micrometers.

PlateReadingController.set_deltat(self, delta):
Sets the time interval between acquisitions.

PlateReadingController.set_af_flag(self, flag):
Sets the autofocus flag.

PlateReadingController.set_crop(self, crop_width, height):
Sets the crop dimensions for acquired images.

PlateReadingController.set_base_path(self, path):
Sets the base path for saving experiment data.

PlateReadingController.start_new_experiment(self, experiment_ID):
Prepares a new folder for the experiment and saves the current configuration.

PlateReadingController.set_selected_configurations(self, selected_configurations_name):
Sets the selected imaging configurations for the experiment.

PlateReadingController.set_selected_columns(self, selected_columns):
Sets the selected columns for plate reading.

PlateReadingController.run_acquisition():
Starts the plate reading acquisition process in a separate thread.

PlateReadingController.stop_acquisition():
Stops the ongoing acquisition process.

PlateReadingController._on_acquisition_completed():
Handles cleanup and restoration of settings after acquisition is completed.

PlateReadingController.slot_image_to_display(self, image):
Slot for emitting the acquired image for display.

PlateReadingController.slot_image_to_display_multi(self, image, illumination_source):
Slot for emitting the acquired image and illumination source for multi-channel display.

PlateReadingController.slot_current_configuration(self, configuration):
Slot for updating the current imaging configuration.
File: ./software/control/gxipy/gxidef.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

class GxFrameStatusList:
    """Frame state code"""

class GxDeviceClassList:
    """Device type code"""

class GxAccessMode:
    """Device access modes"""

class GxAccessStatus:
    """Device access status"""

class GxIPConfigureModeList:
    """IP configuration modes"""

class GxPixelSizeEntry:
    """Pixel size entries"""

class GxPixelColorFilterEntry:
    """Pixel color filter entries"""

class GxPixelFormatEntry:
    """Pixel format entries"""

class GxAcquisitionModeEntry:
    """Acquisition mode entries"""

class GxTriggerSourceEntry:
    """Trigger source entries"""

class GxTriggerActivationEntry:
    """Trigger activation entries"""

class GxExposureModeEntry:
    """Exposure mode entries"""

class GxUserOutputSelectorEntry:
    """User output selector entries"""

class GxUserOutputModeEntry:
    """User output mode entries"""

class GxGainSelectorEntry:
    """Gain selector entries"""

class GxBlackLevelSelectEntry:
    """Black level selector entries"""

class GxBalanceRatioSelectorEntry:
    """Balance ratio selector entries"""

class GxAALightEnvironmentEntry:
    """Auto algorithm light environment entries"""

class GxUserSetEntry:
    """User set entries"""

class GxAWBLampHouseEntry:
    """Auto white balance lamp house entries"""

class GxTestPatternEntry:
    """Test pattern entries"""

class GxTriggerSelectorEntry:
    """Trigger selector entries"""

class GxLineSelectorEntry:
    """Line selector entries"""

class GxLineModeEntry:
    """Line mode entries"""

class GxLineSourceEntry:
    """Line source entries"""

class GxEventSelectorEntry:
    """Event selector entries"""

class GxLutSelectorEntry:
    """LUT selector entries"""

class GxTransferControlModeEntry:
    """Transfer control mode entries"""

class GxTransferOperationModeEntry:
    """Transfer operation mode entries"""

class GxTestPatternGeneratorSelectorEntry:
    """Test pattern generator selector entries"""

class GxChunkSelectorEntry:
    """Chunk selector entries"""

class GxBinningHorizontalModeEntry:
    """Binning horizontal mode entries"""

class GxBinningVerticalModeEntry:
    """Binning vertical mode entries"""

class GxAcquisitionStatusSelectorEntry:
    """Acquisition status selector entries"""

class GxGammaModeEntry:
    """Gamma mode entries"""

class GxColorTransformationModeEntry:
    """Color transformation mode entries"""

class GxColorTransformationValueSelectorEntry:
    """Color transformation value selector entries"""

class GxAutoEntry:
    """Auto mode entries"""

class GxSwitchEntry:
    """Switch entries"""

class GxRegionSendModeEntry:
    """Region send mode entries"""

class GxRegionSelectorEntry:
    """Region selector entries"""

class DxBayerConvertType:
    """Image interpolation method"""

class DxValidBit:
    """Image valid bit"""

class DxImageMirrorMode:
    """Image mirror method"""
File: ./software/control/microcontroller.py
__init__(self, version='Arduino Due', sn=None, parent=None):
    """Initialize Microcontroller object.
    
    Args:
        version (str): Controller version
        sn (str): Serial number
        parent: Parent object
    """

close(self):
    """Close serial connection and stop reading thread."""

reset(self):
    """Reset the microcontroller."""

initialize_drivers(self):
    """Initialize the motor drivers."""

turn_on_illumination(self):
    """Turn on illumination."""

turn_off_illumination(self):
    """Turn off illumination."""

set_illumination(self, illumination_source, intensity, r=None, g=None, b=None):
    """Set illumination intensity.
    
    Args:
        illumination_source: Light source
        intensity: Intensity value
        r,g,b: RGB values
    """

set_illumination_led_matrix(self, illumination_source, r, g, b):
    """Set LED matrix illumination.
    
    Args:
        illumination_source: Light source
        r,g,b: RGB values
    """

send_hardware_trigger(self, control_illumination=False, illumination_on_time_us=0, trigger_output_ch=0):
    """Send hardware trigger.
    
    Args:
        control_illumination (bool): Control illumination
        illumination_on_time_us (int): Illumination on time in microseconds
        trigger_output_ch (int): Trigger output channel
    """

set_strobe_delay_us(self, strobe_delay_us, camera_channel=0):
    """Set strobe delay.
    
    Args:
        strobe_delay_us (int): Strobe delay in microseconds
        camera_channel (int): Camera channel
    """

move_x_usteps(self, usteps):
    """Move X axis by number of microsteps.
    
    Args:
        usteps (int): Number of microsteps
    """

move_x_to_usteps(self, usteps):
    """Move X axis to absolute position in microsteps.
    
    Args:
        usteps (int): Target position in microsteps
    """

move_y_usteps(self, usteps):
    """Move Y axis by number of microsteps.
    
    Args:
        usteps (int): Number of microsteps
    """

move_y_to_usteps(self, usteps):
    """Move Y axis to absolute position in microsteps.
    
    Args:
        usteps (int): Target position in microsteps
    """

move_z_usteps(self, usteps):
    """Move Z axis by number of microsteps.
    
    Args:
        usteps (int): Number of microsteps
    """

move_z_to_usteps(self, usteps):
    """Move Z axis to absolute position in microsteps.
    
    Args:
        usteps (int): Target position in microsteps
    """

move_theta_usteps(self, usteps):
    """Move theta axis by number of microsteps.
    
    Args:
        usteps (int): Number of microsteps
    """

set_off_set_velocity_x(self, off_set_velocity):
    """Set offset velocity for X axis.
    
    Args:
        off_set_velocity (float): Offset velocity in mm/s
    """

set_off_set_velocity_y(self, off_set_velocity):
    """Set offset velocity for Y axis.
    
    Args:
        off_set_velocity (float): Offset velocity in mm/s
    """

home_x(self):
    """Home X axis."""

home_y(self):
    """Home Y axis."""

home_z(self):
    """Home Z axis."""

home_theta(self):
    """Home theta axis."""

home_xy(self):
    """Home X and Y axes."""

zero_x(self):
    """Set current X position as zero."""

zero_y(self):
    """Set current Y position as zero."""

zero_z(self):
    """Set current Z position as zero."""

zero_theta(self):
    """Set current theta position as zero."""

configure_stage_pid(self, axis, transitions_per_revolution, flip_direction=False):
    """Configure PID for stage.
    
    Args:
        axis (int): Axis number
        transitions_per_revolution (int): Transitions per revolution
        flip_direction (bool): Flip direction
    """

turn_on_stage_pid(self, axis):
    """Turn on PID for stage axis.
    
    Args:
        axis (int): Axis number
    """

turn_off_stage_pid(self, axis):
    """Turn off PID for stage axis.
    
    Args:
        axis (int): Axis number
    """

set_pid_arguments(self, axis, pid_p, pid_i, pid_d):
    """Set PID arguments.
    
    Args:
        axis (int): Axis number
        pid_p (float): Proportional gain
        pid_i (float): Integral gain
        pid_d (float): Derivative gain
    """

set_lim(self, limit_code, usteps):
    """Set limit.
    
    Args:
        limit_code (int): Limit code
        usteps (int): Microsteps
    """

set_limit_switch_polarity(self, axis, polarity):
    """Set limit switch polarity.
    
    Args:
        axis (int): Axis number
        polarity (int): Polarity value
    """

set_home_safety_margin(self, axis, margin):
    """Set home safety margin.
    
    Args:
        axis (int): Axis number
        margin (int): Safety margin
    """

configure_motor_driver(self, axis, microstepping, current_rms, I_hold):
    """Configure motor driver.
    
    Args:
        axis (int): Axis number
        microstepping (int): Microstepping value
        current_rms (int): RMS current in mA
        I_hold (float): Hold current ratio (0.0-1.0)
    """

set_max_velocity_acceleration(self, axis, velocity, acceleration):
    """Set maximum velocity and acceleration.
    
    Args:
        axis (int): Axis number
        velocity (float): Maximum velocity in mm/s
        acceleration (float): Maximum acceleration in mm/s^2
    """

set_leadscrew_pitch(self, axis, pitch_mm):
    """Set leadscrew pitch.
    
    Args:
        axis (int): Axis number
        pitch_mm (float): Pitch in mm
    """

configure_actuators(self):
    """Configure actuators with default settings."""

ack_joystick_button_pressed(self):
    """Acknowledge joystick button press."""

analog_write_onboard_DAC(self, dac, value):
    """Write analog value to onboard DAC.
    
    Args:
        dac (int): DAC number
        value (int): Analog value
    """

configure_dac80508_refdiv_and_gain(self, div, gains):
    """Configure DAC80508 reference divider and gain.
    
    Args:
        div (int): Divider value
        gains (int): Gain values
    """

set_pin_level(self, pin, level):
    """Set pin level.
    
    Args:
        pin (int): Pin number
        level (int): Pin level
    """

turn_on_AF_laser(self):
    """Turn on autofocus laser."""

turn_off_AF_laser(self):
    """Turn off autofocus laser."""

send_command(self, command):
    """Send command to microcontroller.
    
    Args:
        command (bytearray): Command to send
    """

resend_last_command(self):
    """Resend last command."""

read_received_packet(self):
    """Read and process received packets."""

get_pos(self):
    """Get current position.
    
    Returns:
        tuple: (x_pos, y_pos, z_pos, theta_pos)
    """

get_button_and_switch_state(self):
    """Get button and switch state.
    
    Returns:
        int: Button and switch state
    """

is_busy(self):
    """Check if microcontroller is busy.
    
    Returns:
        bool: True if busy, False otherwise
    """

set_callback(self, function):
    """Set callback function for new packets.
    
    Args:
        function: Callback function
    """

wait_till_operation_is_completed(self, TIMEOUT_LIMIT_S=5):
    """Wait until current operation is completed.
    
    Args:
        TIMEOUT_LIMIT_S (int): Timeout limit in seconds
    """

set_dac80508_scaling_factor_for_illumination(self, illumination_intensity_factor):
    """Set DAC80508 scaling factor for illumination.
    
    Args:
        illumination_intensity_factor (float): Intensity factor (0.0-1.0)
    """
File: ./software/control/gxipy/gxwrapper.py
Here are the extracted method headers with docstring descriptions:

def gx_init_lib():
    """
    :brief      Initialize the device library for some resource application operations
    :return:    None
    """

def gx_close_lib():
    """
    :brief      Close the device library to release resources.
    :return:    None
    """

def gx_get_last_error(size=1024):
    """
    :brief      To get the latest error descriptions information of the program
    :param      size:           string buff length(size=1024)
                                Type: Int, Minnum: 0
    :return:    status:         State return value, See detail in GxStatusList
                err_code:       Return the last error code
                err_content:    the latest error descriptions information of the program
    """

def gx_update_device_list(time_out=200):
    """
    :brief      Enumerating currently all available devices in subnet and gets the number of devices.
    :param      time_out:           The timeout time of enumeration (unit: ms).
                                    Type: Int, Minimum:0
    :return:    status:             State return value, See detail in GxStatusList
                device_num:         The number of devices
    """

def gx_update_all_device_list(time_out=200):
    """
    :brief      Enumerating currently all available devices in entire network and gets the number of devices
    :param      time_out:           The timeout time of enumeration (unit: ms).
                                    Type: Int, Minimum: 0
    :return:    status:             State return value, See detail in GxStatusList
                device_num:         The number of devices
    """

def gx_get_all_device_base_info(devices_num):
    """
    :brief      To get the basic information of all the devices
    :param      devices_num:        The number of devices
                                    Type: Int, Minimum: 0
    :return:    status:             State return value, See detail in GxStatusList
                device_ip_info:     The structure pointer of the device information(GxDeviceIPInfo)
    """

def gx_get_device_ip_info(index):
    """
    :brief      To get the network information of the device.
    :param      index:              Device index
                                    Type: Int, Minimum: 1
    :return:    status:             State return value, See detail in GxStatusList
                device_ip_info:     The structure pointer of the device information(GxDeviceIPInfo)
    """

def gx_open_device_by_index(index):
    """
    :brief      Open the device by a specific Index(1, 2, 3, ...)
    :param      index:          Device index
                                Type: Int, Minimum: 1
    :return:    status:         State return value, See detail in GxStatusList
                handle:         The device handle returned by the interface
    """

def gx_open_device(open_param):
    """
    :brief      Open the device by a specific unique identification, such as: SN, IP, MAC, Index etc.
    :param      open_param:     The open device parameter which is configurated by the user.
                                Type: GxOpenParam
    :return:    status:         State return value, See detail in GxStatusList
                handle:         The device handle returned by the interface
    """

def gx_close_device(handle):
    """
    :brief      Specify the device handle to close the device
    :param      handle:     The device handle that the user specified to close.
                            Type: Long, Greater than 0
    :return:    status:     State return value, See detail in GxStatusList
    """

def gx_get_feature_name(handle, feature_id):
    """
    :brief      Get the string description for the feature code
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: Int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                name:           The string description for the feature code
    """

def gx_is_implemented(handle, feature_id):
    """
    :brief      Inquire the current camera whether support a special feature.
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                is_implemented: To return the result whether is support this feature
    """

def gx_is_readable(handle, feature_id):
    """
    :brief      Inquire if a feature code is currently readable
    :param      handle:             The handle of the device
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                is_readable:        To return the result whether the feature code ID is readable
    """

def gx_is_writable(handle, feature_id):
    """
    :brief      Inquire if a feature code is currently writable
    :param      handle:             The handle of the device.
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                is_writeable:       To return the result whether the feature code ID is writable(Bool)
    """

def gx_get_int_range(handle, feature_id):
    """
    :brief      To get the minimum value, maximum value and steps of the int type
    :param      handle:         The handle of the device.
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                int_range:      The structure of range description(GxIntRange)
    """

def gx_get_int(handle, feature_id):
    """
    :brief      Get the current value of the int type.
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                int_value:      Get the current value of the int type
    """

def gx_set_int(handle, feature_id, int_value):
    """
    :brief      Set the value of int type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID.
                                Type: int, Greater than 0
    :param      int_value:      The value that the user will set
                                Type: long, minnum:0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_float_range(handle, feature_id):
    """
    :brief      To get the minimum value, maximum value, stepsand unit of the float type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                float_range:    The description structure(GxFloatRange)
    """

def gx_set_float(handle, feature_id, float_value):
    """
    :brief      Set the value of float type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :param      float_value:    The float value that the user will set
                                Type: double
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_float(handle, feature_id):
    """
    :brief      Get the value of float type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_enum_entry_nums(handle, feature_id):
    """
    :brief      Get the number of the options for the enumeration item
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                enum_num:       The number of the options for the enumeration item
    """

def gx_get_enum_description(handle, feature_id, enum_num):
    """
    :brief      To get the description information of the enumerated type values
                the number of enumerated items and the value and descriptions of each item
                please reference GxEnumDescription.
    :param      handle:             The handle of the device
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :param      enum_num:           The number of enumerated information
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                enum_description:   Enumerated information array(GxEnumDescription)
    """

def gx_get_enum(handle, feature_id):
    """
    :brief      To get the current enumeration value
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                enum_value:     Get the current enumeration value
    """

def gx_set_enum(handle, feature_id, enum_value):
    """
    :brief      Set the enumeration value
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :param      enum_value:     Set the enumeration value
                                Type: int
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_bool(handle, feature_id):
    """
    :brief      Get the value of bool type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                boot_value:     the value of bool type
    """

def gx_set_bool(handle, feature_id, bool_value):
    """
    :brief      Set the value of bool type
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :param      bool_value:     The bool value that the user will set
                                Type: Bool
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_string_length(handle, feature_id):
    """
    :brief      Get the current value length of the character string type. Unit: byte
    :param      handle:             The handle of the device
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                string_length:      the current value length of the character string type
    """

def gx_get_string_max_length(handle, feature_id):
    """
    :brief      Get the maximum length of the string type value,  Unit: byte
    :param      handle:             The handle of the device
                                    Type: Long, Greater than 0
    :param      feature_id:         The feature code ID
                                    Type: int, Greater than 0
    :return:    status:             State return value, See detail in GxStatusList
                string_max_length:  the maximum length of the string type value
    """

def gx_get_string(handle, feature_id):
    """
    :brief      Get the content of the string type value
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_set_string(handle, feature_id, content):
    """
    :brief      Set the content of the string value
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :param      content:        The string will be setting(str)
                                Type: str
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_get_buffer_length(handle, feature_id):
    """
    :brief      Get the length of the chunk data and the unit is byte,
                the user can apply the buffer based on the length obtained,
                and then call the gx_get_buffer to get the chunk data.
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                buff_length:    Buff length, Unit: byte
    """

def gx_get_buffer(handle, feature_id):
    """
    :brief      Get the chunk data
    :param      handle:         The handle of the device
                                Type: Long, Greater than 0
    :param      feature_id:     The feature code ID
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
                buff:           chunk data
    """

def gx_set_buffer(handle, feature_id, buff, buff_size):
    """
    :brief      Set the chunk data
    :param      handle:         The handle of the device
    :param      feature_id:     The feature code ID
                                Type: long, Greater than 0
    :param      buff:           chunk data buff
                                Type: Ctype array
    :param      buff_size:      chunk data buff size
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_send_command(handle, feature_id):
    """
    :brief      Send the command
    :param      handle:         The handle of the device
                                Type: long, Greater than 0
    :param      feature_id:     The feature code ID.
                                Type: int, Greater than 0
    :return:    status:         State return value, See detail in GxStatusList
    """

def gx_register_capture_callback(handle, cap_call):
    """
    :brief      Register the capture callback function
    :param      handle:         The handle of the device
    :param      cap_call:       The callback function that
File: ./software/control/gxipy/__init__.py
gxwrapper(func)
Wrapper function for GXI API calls. Handles error checking and exception raising.

dxwrapper(func)
Wrapper function for DX API calls. Handles error checking and exception raising.
File: ./software/control/ImSwitch/shortcut.py
class shortcut:
    """ Decorator for shortcuts. """

def __init__(self, key, name):
    """Initialize shortcut decorator with key and name."""

def __call__(self, func):
    """Apply shortcut decorator to function."""

def generateShortcuts(objs):
    """ Generates a dict from shortcut-decorated methods in the objects in the
    passed array objs. """
File: ./software/control/ImSwitch/imagetools.py
def bestLevels(arr):
    """
    Calculates optimal minimum and maximum levels for image contrast adjustment.
    Uses algorithm from ImageJ. Takes numpy array as input.
    Returns tuple of (min_level, max_level).
    Keywords: image processing, contrast adjustment, histogram analysis
    """

def minmaxLevels(arr):
    """
    Calculates simple minimum and maximum levels for image contrast adjustment.
    Takes numpy array as input. Returns tuple of (min_level, max_level).
    Keywords: image processing, contrast adjustment, min-max normalization
    """
File: ./software/control/gui_camera_only_tiscamera.py
OctopiGUI.__init__(self, *args, **kwargs):
Initializes the OctopiGUI class, setting up the camera, microcontroller, configuration manager, stream handler, live controller, image saver, and image display. It also creates and layouts widgets, sets up connections between components, and opens the image display window.

OctopiGUI.closeEvent(self, event):
Handles the closing of the application, stopping live operations, closing the camera, image saver, image display, and image display window.
File: ./software/control/gui_tiscamera_simulation.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def __init__(self, *args, **kwargs):
    """Initialize the OctopiGUI class. Sets up camera, microcontroller, controllers, widgets, and connections."""

def closeEvent(self, event):
    """Handle closing of the application. Stops live view, closes camera and other resources."""
File: ./software/control/utils_config.py
def generate_default_configuration(filename):
    """
    Generates a default XML configuration file for imaging modes.
    
    Creates an XML structure with various imaging modes, each containing settings
    for exposure time, analog gain, illumination source and intensity, camera
    serial number, Z offset, pixel format, and emission filter position.
    
    Modes include brightfield, darkfield, and fluorescence configurations
    for different excitation wavelengths.
    
    Args:
    filename (str): The name of the XML file to be created.
    
    Key concepts: XML generation, imaging modes, microscopy settings
    """
File: ./software/control/ImSwitch/napariViewerWidget.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

__init__(self, *args, **kwargs):
Widget containing viewbox that displays the new detector frames.

setLiveViewLayers(self, names):

addStaticLayer(self, name, im):

getCurrentImageName(self):

getImage(self, name):

setImage(self, name, im, scale = None):

clearImage(self, name):

getImageDisplayLevels(self, name):

setImageDisplayLevels(self, name, minimum, maximum):

getCenterViewbox(self):
Returns the center point of the viewbox, as an (x, y) tuple.

updateGrid(self, imShape):

setGridVisible(self, visible):

setCrosshairVisible(self, visible):

resetView(self):

addItem(self, item):

removeItem(self, item):
File: ./software/control/gui.py
OctopiGUI.__init__(self, is_simulation = False, *args, **kwargs):
    """
    Initializes the OctopiGUI class.
    
    Args:
    - is_simulation (bool): Flag to determine if running in simulation mode
    
    Key components:
    - Camera and microcontroller setup
    - GUI widgets and layout
    - Signal connections
    """

OctopiGUI.closeEvent(self, event):
    """
    Handles the closing of the application.
    
    Actions:
    - Stops live view
    - Closes camera and microcontroller connections
    - Closes image saving and display processes
    """
File: ./software/control/processing_handler.py
def default_image_preprocessor(image, callable_list):
    """
    Applies a list of callable functions to an image.
    :param image: ndarray representing an image
    :param callable_list: List of dictionaries with functions and their arguments
    :return: Processed image
    Keywords: image processing, preprocessing, function application
    """

class ProcessingHandler():
    """
    Handler class for parallelizing FOV processing.
    Manages processing and upload queues for image processing tasks.
    Keywords: parallel processing, image processing, queue management
    """

    def processing_queue_handler(self, queue_timeout=None):
        """
        Handles the processing queue, executing tasks and moving results to upload queue.
        :param queue_timeout: Timeout for queue operations
        Keywords: queue processing, task execution
        """

    def upload_queue_handler(self, queue_timeout=None):
        """
        Handles the upload queue, executing upload tasks.
        :param queue_timeout: Timeout for queue operations
        Keywords: queue processing, data upload
        """

    def start_processing(self, queue_timeout=None):
        """
        Starts the processing thread.
        :param queue_timeout: Timeout for queue operations
        Keywords: thread management, processing initiation
        """

    def start_uploading(self,queue_timeout=None):
        """
        Starts the uploading thread.
        :param queue_timeout: Timeout for queue operations
        Keywords: thread management, upload initiation
        """

    def end_uploading(self, *args, **kwargs):
        """
        Signals the end of uploading tasks.
        :return: End signal dictionary
        Keywords: upload termination
        """

    def end_processing(self):
        """
        Signals the end of processing tasks and initiates upload termination.
        Keywords: processing termination, cleanup
        """
File: ./software/control/widgets_usbspectrometer.py
SpectrometerControlWidget.__init__(self, spectrometer, streamHandler, *args, **kwargs):
Initializes the SpectrometerControlWidget with spectrometer and streamHandler objects.

SpectrometerControlWidget.add_components(self):
Adds UI components for controlling the spectrometer, including live button and exposure time input.

SpectrometerControlWidget.toggle_live(self, pressed):
Toggles the spectrometer streaming on or off based on the live button state.

RecordingWidget.__init__(self, streamHandler, imageSaver, main=None, *args, **kwargs):
Initializes the RecordingWidget with streamHandler and imageSaver objects.

RecordingWidget.add_components(self):
Adds UI components for recording control, including saving directory, experiment ID, and recording options.

RecordingWidget.set_saving_dir(self):
Opens a dialog to set the base saving directory for recordings.

RecordingWidget.toggle_recording(self, pressed):
Starts or stops recording based on the record button state.

RecordingWidget.stop_recording(self):
Stops the recording and resets UI elements.

SpectrumDisplay.__init__(self, N=1000, main=None, *args, **kwargs):
Initializes the SpectrumDisplay widget with a default size of 1000.

SpectrumDisplay.add_components(self):
Adds the plot widget to display the spectrum.

SpectrumDisplay.plot(self, data):
Plots the spectrum data on the display.

PlotWidget.__init__(self, title='', parent=None, add_legend=False):
Initializes a custom plot widget with optional title and legend.

PlotWidget.plot(self, x, y, clear=False):
Plots data on the custom plot widget, with option to clear previous plots.
File: ./software/control/RCM_API.py
RCM_API.__init__(self)
"""Initializes the RCM_API class, loading macros and functions from the header file and DLL."""

RCM_API.get_string_parameter(self, param: int)
"""Retrieves a string parameter from the device. Returns the parameter value as a string or None if an error occurs."""

RCM_API.set_integer_parameter(self, param: int, value: int)
"""Sets an integer parameter on the device. Returns the result of the operation."""

RCM_API.set_float_parameter(self, param: int, value: float)
"""Sets a float parameter on the device. Returns the result of the operation."""

RCM_API.initialize_device(self, simulated: bool)
"""Initializes the device. The 'simulated' parameter determines whether to use a simulated device. Returns the result of the initialization."""

RCM_API.get_device_type(self)
"""Retrieves the type of the connected device. Returns the device type."""

RCM_API.start_acquisition(self)
"""Starts the acquisition process on the device. Returns the result of the operation."""

RCM_API.set_bypass(self, mode: int)
"""Sets the bypass mode on the device. Returns the result of the operation."""

RCM_API.start_continuous_acquisition(self)
"""Starts continuous acquisition on the device. Returns the result of the operation."""

RCM_API.stop_continuous_acquisition(self)
"""Stops continuous acquisition on the device. Returns the result of the operation."""

RCM_API.get_full_error(self)
"""Retrieves the full error information from the device. Returns a tuple containing the error code and error message, or None if an error occurs."""

extract_macros_from_header(file_path)
"""Extracts macro definitions from a C header file. Returns a dictionary of macro names and their integer values."""

extract_functions_from_header(file_path)
"""Extracts function prototypes from a C header file. Returns a list of dictionaries containing function names, return types, and argument types."""
File: ./software/control/utils_/image_processing.py
def default_lower_HSV(color):
    """Calculate default lower HSV color bounds."""

def default_upper_HSV(color):
    """Calculate default upper HSV color bounds."""

def threshold_image(image_BGR,LOWER,UPPER):
    """Threshold image using HSV color bounds."""

def threshold_image_gray(image_gray, LOWER, UPPER):
    """Threshold grayscale image using intensity bounds."""

def bgr2gray(image_BGR):
    """Convert BGR image to grayscale."""

def crop(image,center,imSize):
    """Crop image around center point."""

def crop_image(image,crop_width,crop_height):
    """Crop image to specified dimensions."""

def get_bbox(cnt):
    """Get bounding box of contour."""

def find_centroid_enhanced(image,last_centroid):
    """Find centroid maximizing tracking metric."""

def find_centroid_enhanced_Rect(image,last_centroid):
    """Find centroid maximizing tracking metric and bounding rectangle."""

def find_centroid_basic(image):
    """Find centroid of largest contour."""

def find_centroid_basic_Rect(image):
    """Find centroid of largest contour and bounding rectangle."""

def scale_square_bbox(bbox, scale_factor, square = True):
    """Scale bounding box, optionally making it square."""

def get_image_center_width(image):
    """Get image center point and width."""

def get_image_height_width(image):
    """Get image height and width."""

def get_image_top_center_width(image):
    """Get image top center point and width."""

def YTracking_Objective_Function(image, color):
    """Calculate variance-based objective function for Y tracking."""

def calculate_focus_measure(image):
    """Calculate focus measure using Laplacian variance."""
File: ./software/control/tracking.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def track(self, image, thresh_image, is_first_frame = False):
    """
    Track an object in an image.
    Initializes tracker on first frame or when inactive.
    Updates tracker position on subsequent frames.
    Returns if centroid found, centroid position, and bounding rectangle points.
    """

def reset(self):
    """
    Reset the image tracker state.
    Sets first frame flag, deactivates tracker, and clears centroid.
    """

def create_tracker(self):
    """
    Create a tracker object based on the selected tracker type.
    Initializes OpenCV or neural network based tracker.
    """

def _initialize_tracker(self, image, centroid, bbox):
    """
    Initialize the tracker with the given image, centroid and bounding box.
    Handles initialization for OpenCV and neural network based trackers.
    """

def _update_tracker(self, image, thresh_image):
    """
    Update the tracker position given a new image frame.
    Handles updates for OpenCV, neural network, and basic thresholding trackers.
    Returns if object found and new bounding box.
    """

def update_tracker_type(self, tracker_type):
    """
    Update the type of tracker being used.
    Connected to signal from Tracking Widget.
    """

def update_init_method(self, method):
    """
    Update the initialization method for the tracker.
    """

def centroid_from_bbox(self, bbox):
    """
    Calculate the centroid coordinates from a bounding box.
    """

def rectpts_from_bbox(self, bbox):
    """
    Calculate rectangle points from a bounding box.
    """

def update_searchArea(self, value):
    """
    Update the search area for the tracker.
    """

def set_roi_bbox(self, bbox):
    """
    Set the region of interest bounding box.
    Updates from ImageDisplayWindow.
    """
File: ./software/control/toupcam.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def Version():
    """get the version of this dll, which is: 54.23714.20231029"""

def GigeEnable(fun, ctx):
    """Initialize support for GigE cameras. If online/offline notifications are not required, the callback function can be set to None"""

def HotPlug(fun, ctx):
    """
    USB hotplug is only available on macOS and Linux, it's unnecessary on Windows & Android. To process the device plug in / pull out:
        (1) On Windows, please refer to the MSDN
            (a) Device Management, https://docs.microsoft.com/en-us/windows/win32/devio/device-management
            (b) Detecting Media Insertion or Removal, https://docs.microsoft.com/en-us/windows/win32/devio/detecting-media-insertion-or-removal
        (2) On Android, please refer to https://developer.android.com/guide/topics/connectivity/usb/host
        (3) On Linux / macOS, please call this function to register the callback function.
            When the device is inserted or pulled out, you will be notified by the callback funcion, and then call Toupcam_EnumV2(...) again to enum the cameras.
        (4) On macOS, IONotificationPortCreate series APIs can also be used as an alternative.
    """

def EnumV2():
    """Enumerate Toupcam cameras"""

def EnumWithName():
    """Enumerate Toupcam cameras with names"""

def Open(camId):
    """
    the object of Toupcam must be obtained by classmethod Open or OpenByIndex, it cannot be obtained by obj = toupcam.Toupcam()
    Open(None) means try to Open the first enumerated camera
    """

def OpenByIndex(index):
    """
    the object of Toupcam must be obtained by classmethod Open or OpenByIndex, it cannot be obtained by obj = toupcam.Toupcam()

    the same with Toupcam_Open, but use the index as the parameter. such as:
    index == 0, open the first camera,
    index == 1, open the second camera,
    etc
    """

def Close(self):
    """Close the camera"""

def StartPullModeWithCallback(self, fun, ctx):
    """Start pull mode with callback"""

def PullImageV3(self, pImageData, bStill, bits, rowPitch, pInfo):
    """Pull image in V3 format"""

def WaitImageV3(self, nWaitMS, pImageData, bStill, bits, rowPitch, pInfo):
    """Wait for image in V3 format"""

def PullImageV2(self, pImageData, bits, pInfo):
    """Pull image in V2 format"""

def PullStillImageV2(self, pImageData, bits, pInfo):
    """Pull still image in V2 format"""

def PullImageWithRowPitchV2(self, pImageData, bits, rowPitch, pInfo):
    """Pull image with row pitch in V2 format"""

def PullStillImageWithRowPitchV2(self, pImageData, bits, rowPitch, pInfo):
    """Pull still image with row pitch in V2 format"""

def ResolutionNumber(self):
    """Get number of resolutions"""

def StillResolutionNumber(self):
    """return (width, height)"""

def MonoMode(self):
    """Get mono mode"""

def MaxSpeed(self):
    """get the maximum speed, 'Frame Speed Level'"""

def MaxBitDepth(self):
    """get the max bitdepth of this camera, such as 8, 10, 12, 14, 16"""

def FanMaxSpeed(self):
    """get the maximum fan speed, fan speed range = [0, max], closed interval"""

def Revision(self):
    """get the revision"""

def SerialNumber(self):
    """get the serial number which is always 32 chars which is zero-terminated such as: TP110826145730ABCD1234FEDC56787"""

def FwVersion(self):
    """get the camera firmware version, such as: 3.2.1.20140922"""

def HwVersion(self):
    """get the camera hardware version, such as: 3.2.1.20140922"""

def ProductionDate(self):
    """such as: 20150327"""

def FpgaVersion(self):
    """Get FPGA version"""

def Field(self):
    """Get field"""

def Stop(self):
    """Stop capture"""

def Pause(self, bPause):
    """1 => pause, 0 => continue"""

def Snap(self, nResolutionIndex):
    """still image snap, nResolutionIndex = 0xffffffff means use the cureent preview resolution"""

def SnapN(self, nResolutionIndex, nNumber):
    """multiple still image snap, nResolutionIndex = 0xffffffff means use the cureent preview resolution"""

def SnapR(self, nResolutionIndex, nNumber):
    """multiple RAW still image snap, nResolutionIndex = 0xffffffff means use the cureent preview resolution"""

def Trigger(self, nNumber):
    """
    soft trigger:
    nNumber:    0xffff:     trigger continuously
                0:          cancel trigger
                others:     number of images to be triggered
    """

def TriggerSync(self, nTimeout, pImageData, bits, rowPitch, pInfo):
    """
    trigger synchronously
    nTimeout:   0:              by default, exposure * 102% + 4000 milliseconds
                0xffffffff:     wait infinite
                other:          milliseconds to wait        
    """

def put_Size(self, nWidth, nHeight):
    """Set size"""

def get_Size(self):
    """return (width, height)"""

def put_eSize(self, nResolutionIndex):
    """
    put_Size, put_eSize, can be used to set the video output resolution BEFORE Start.
    put_Size use width and height parameters, put_eSize use the index parameter.
    for example, UCMOS03100KPA support the following resolutions:
        index 0:    2048,   1536
        index 1:    1024,   768
        index 2:    680,    510
    so, we can use put_Size(h, 1024, 768) or put_eSize(h, 1). Both have the same effect.
    """

def get_eSize(self):
    """Get eSize"""

def get_FinalSize(self):
    """final size after ROI, rotate, binning"""

def get_Resolution(self, nResolutionIndex):
    """return (width, height)"""

def get_PixelSize(self, nResolutionIndex):
    """get the sensor pixel size, such as: 2.4um x 2.4um"""

def get_ResolutionRatio(self, nResolutionIndex):
    """numerator/denominator, such as: 1/1, 1/2, 1/3"""

def get_RawFormat(self):
    """
    see: http://www.fourcc.org
    FourCC:
        MAKEFOURCC('G', 'B', 'R', 'G'), see http://www.siliconimaging.com/RGB%20Bayer.htm
        MAKEFOURCC('R', 'G', 'G', 'B')
        MAKEFOURCC('B', 'G', 'G', 'R')
        MAKEFOURCC('G', 'R', 'B', 'G')
        MAKEFOURCC('Y', 'Y', 'Y', 'Y'), monochromatic sensor
        MAKEFOURCC('Y', '4', '1', '1'), yuv411
        MAKEFOURCC('V', 'U', 'Y', 'Y'), yuv422
        MAKEFOURCC('U', 'Y', 'V', 'Y'), yuv422
        MAKEFOURCC('Y', '4', '4', '4'), yuv444
        MAKEFOURCC('R', 'G', 'B', '8'), RGB888
    """

def put_RealTime(self, val):
    """
    0: stop grab frame when frame buffer deque is full, until the frames in the queue are pulled away and the queue is not full
    1: realtime
        use minimum frame buffer. When new frame arrive, drop all the pending frame regardless of whether the frame buffer is full.
        If DDR present, also limit the DDR frame buffer to only one frame.
    2: soft realtime
        Drop the oldest frame when the queue is full and then enqueue the new frame
    default: 0
    """

def get_RealTime(self):
    """Get real time mode"""

def Flush(self):
    """Flush is obsolete, recommend using put_Option(h, TOUPCAM_OPTION_FLUSH, 3)"""

def get_AutoExpoEnable(self):
    """
    bAutoExposure:
       0: disable auto exposure
       1: auto exposure continue mode
       2: auto exposure once mode
    """

def put_AutoExpoEnable(self, bAutoExposure):
    """
    bAutoExposure:
       0: disable auto exposure
       1: auto exposure continue mode
       2: auto exposure once mode
    """

def get_AutoExpoTarget(self):
    """Get auto exposure target"""

def put_AutoExpoTarget(self, Target):
    """Set auto exposure target"""

def put_AutoExpoRange(self, maxTime, minTime, maxGain, minGain):
    """Set auto exposure range"""

def get_AutoExpoRange(self):
    """Get auto exposure range"""

def put_MaxAutoExpoTimeAGain(self, maxTime, maxGain):
    """Set max auto exposure time and gain"""

def get_MaxAutoExpoTimeAGain(self):
    """Get max auto exposure time and gain"""

def put_MinAutoExpoTimeAGain(self, minTime, minGain):
    """Set min auto exposure time and gain"""

def get_MinAutoExpoTimeAGain(self):
    """Get min auto exposure time and gain"""

def get_ExpoTime(self):
    """in microseconds"""

def put_ExpoTime(self, Time):
    """Set exposure time"""

def get_ExpTimeRange(self):
    """Get exposure time range"""

def get_ExpoAGain(self):
    """percent, such as 300"""

def put_ExpoAGain(self, Gain):
    """Set exposure gain"""

def get_ExpoAGainRange(self):
    """ return (min, max, default)"""

def put_LevelRange(self, aLow, aHigh):
    """Set level range"""

def get_LevelRange(self):
    """Get level range"""

def put_LevelRangeV2(self, mode, roiX, roiY, roiWidth, roiHeight, aLow, aHigh):
    """Set level range V2"""

def get_LevelRangeV2(self):
    """Get level range V2"""

def put_Hue(self, Hue):
    """Set hue"""

def get_Hue(self):
    """Get hue"""

def put_Saturation(self, Saturation):
    """Set saturation"""

def get_Saturation(self):
    """Get saturation"""

def put_Brightness(self, Brightness):
    """Set brightness"""

def get_Brightness(self):
    """Get brightness"""

def get_Contrast(self):
    """Get contrast"""

def put_Contrast(self, Contrast):
    """Set contrast"""

def get_Gamma(self):
    """Get gamma"""

def put_Gamma(self, Gamma):
    """Set gamma"""

def get_Chrome(self):
    """monochromatic mode"""

def put_Chrome(self, bChrome):
    """Set chrome"""

def get_VFlip(self):
    """vertical flip"""

def put_VFlip(self, bVFlip):
    """vertical flip"""

def get_HFlip(self):
    """horizontal flip"""

def put_HFlip(self, bHFlip):
    """horizontal flip"""

def get_Negative(self):
    """negative film"""

def put_Negative(self, bNegative):
    """negative film"""

def put_Speed(self, nSpeed):
    """Set speed"""

def get_Speed(self):
    """Get speed"""

def put_HZ(self, nHZ):
    """
    power supply:
        0 => 60HZ AC
        1 => 50Hz AC
        2 => DC
    """

def get_HZ(self):
    """Get HZ"""

def put_Mode(self, bSkip):
    """skip or bin"""

def get_Mode(self):
    """Get mode"""

def put_TempTint(self, nTemp, nTint):
    """White Balance, Temp/Tint mode"""

def get_TempTint(self):
    """White Balance, Temp/Tint mode"""

def put_WhiteBalanceGain(self, aGain):
    """White Balance, RGB Gain Mode"""

def get_WhiteBalanceGain(self):
    """White Balance, RGB Gain Mode"""

def put_AWBAuxRect(self, X, Y, Width, Height):
    """Set auto white balance aux rect"""

def get_AWBAuxRect(self):
    """return (left, top, width, height)"""

def put_AEAuxRect(self, X, Y, Width, Height):
    """Set auto exposure aux rect"""

def get_AEAuxRect(self):
    """return (left, top, width, height)"""

def put_BlackBalance(self, aSub):
    """Set black balance"""

def get_BlackBalance(self):
    """Get black balance"""

def put_ABBAuxRect(self, X, Y, Width, Height):
    """Set auto black balance aux rect"""

def get_ABBAuxRect(self):
    """return (left, top, width, height)"""

def get_StillResolution(self, nResolutionIndex):
    """Get still resolution"""

def put_LEDState(self, iLed, iState, iPeriod):
    """
    led state:
        iLed: Led index, (0, 1, 2, ...)
        iState: 1 => Ever bright; 2 => Flashing; other => Off
        iPeriod: Flashing Period (>= 500ms)
    """

def write_EEPROM(self, addr, pBuffer):
    """Write EEPROM"""

def read_EEPROM(self, addr, pBuffer):
    """Read EEPROM"""

def rwc_Flash(self, action, addr, pData):
    """
    Flash:
    action = TOUPCAM_FLASH_XXXX: read, write, erase, query total size, query read/write block size, query erase block size
    addr = address
    see democpp
    """

def write_Pipe(self, pipeId, pBuffer):
    """Write pipe"""

def read_Pipe(self, pipeId, pBuffer):
    """Read pipe"""

def feed_Pipe(self, pipeId):
    """Feed pipe"""

def write_UART(self, pBuffer):
    """Write UART"""

def read_UART(self, pBuffer):
    """Read UART"""

def put_Option(self, iOption, iValue):
    """Set option"""

def get_Option(self, iOption):
    """Get option"""

def put_Linear(self, v8, v16):
    """Set linear"""

def put_Curve(self, v8, v16):
    """Set curve"""

def put_ColorMatrix(self, v):
    """Set color matrix"""

def
File: ./software/control/gxipy/dxwrapper.py
dx_get_gamma_lut(gamma_param):
    Calculate gamma lookup table (RGB24)
    Parameters:
    - gamma_param: gamma param, range(0.1 ~ 10)
    Returns:
    - status: State return value, See detail in DxStatus
    - gamma_lut: gamma lookup table
    - lut_length: gamma lookup table length (unit: byte)

dx_get_contrast_lut(contrast_param):
    Calculate contrast lookup table (RGB24)
    Parameters:
    - contrast_param: contrast param, range(-50 ~ 100)
    Returns:
    - status: State return value, See detail in DxStatus
    - contrast_lut: contrast lookup table
    - lut_length: contrast lookup table length (unit: byte)

dx_raw8_to_rgb24(input_address, output_address, width, height, convert_type, bayer_type, flip):
    Convert Raw8 to Rgb24
    Parameters:
    - input_address: The input raw image buff address, buff size = width * height
    - output_address: The output rgb image buff address, buff size = width * height * 3
    - width: Image width
    - height: Image height
    - convert_type: Bayer convert type, See detail in DxBayerConvertType
    - bayer_type: pixel color filter, See detail in DxPixelColorFilter
    - flip: Output image flip flag (True: flip, False: no flip)
    Returns:
    - status: State return value, See detail in DxStatus
    - data_array: Array of output images, buff size = width * height * 3

dx_raw16_to_raw8(input_address, out_address, width, height, valid_bits):
    Raw16 converted to Raw8
    Parameters:
    - input_address: The input image buff address, buff size = width * height * 2
    - out_address: The output image buff address, buff size = width * height
    - width: Image width
    - height: Image height
    - valid_bits: Data valid digit, See detail in DxValidBit
    Returns:
    - status: State return value, See detail in DxStatus
    - data_array: Array of output images, buff size = width * height

dx_image_improvement(input_address, output_address, width, height, color_correction_param, contrast_lut, gamma_lut):
    Image quality improvement
    Parameters:
    - input_address: input buffer address, buff size = width * height * 3
    - output_address: input buffer address, buff size = width * height * 3
    - width: image width
    - height: image height
    - color_correction_param: color correction param (get from camera)
    - contrast_lut: contrast lookup table
    - gamma_lut: gamma lookup table
    Returns:
    - status: State return value, See detail in DxStatus
    - data_array: Array of output images, buff size = width * height * 3
File: ./software/control/camera_TIS.py
Camera.__init__(self, sn=None, width=1920, height=1080, framerate=30, color=False):
Initializes the Camera object with specified parameters.

Camera.open(self, index=0):
Opens the camera.

Camera.set_callback(self, function):
Sets a callback function for new images.

Camera.enable_callback(self):
Enables the callback for new samples.

Camera.disable_callback(self):
Disables the callback.

Camera.open_by_sn(self, sn):
Opens the camera by serial number.

Camera.close(self):
Closes the camera and stops streaming.

Camera.set_exposure_time(self, exposure_time):
Sets the exposure time of the camera.

Camera.set_analog_gain(self, analog_gain):
Sets the analog gain of the camera.

Camera.get_awb_ratios(self):
Gets the auto white balance ratios.

Camera.set_wb_ratios(self, wb_r=None, wb_g=None, wb_b=None):
Sets the white balance ratios.

Camera.start_streaming(self):
Starts the camera streaming.

Camera.stop_streaming(self):
Stops the camera streaming.

Camera.set_continuous_acquisition(self):
Sets the camera to continuous acquisition mode.

Camera.set_software_triggered_acquisition(self):
Sets the camera to software-triggered acquisition mode.

Camera.set_hardware_triggered_acquisition(self):
Sets the camera to hardware-triggered acquisition mode.

Camera.send_trigger(self):
Sends a trigger signal to the camera.

Camera.read_frame(self):
Reads the current frame from the camera.

Camera.set_pixel_format(self, format):
Sets the pixel format of the camera.

Camera_Simulation.__init__(self, sn=None, width=640, height=480, framerate=30, color=False):
Initializes the Camera_Simulation object with specified parameters.

Camera_Simulation.open(self, index=0):
Opens the simulated camera.

Camera_Simulation.set_callback(self, function):
Sets a callback function for new images in the simulation.

Camera_Simulation.enable_callback(self):
Enables the callback for the simulated camera.

Camera_Simulation.disable_callback(self):
Disables the callback for the simulated camera.

Camera_Simulation.open_by_sn(self, sn):
Opens the simulated camera by serial number.

Camera_Simulation.close(self):
Closes the simulated camera.

Camera_Simulation.set_exposure_time(self, exposure_time):
Sets the exposure time of the simulated camera.

Camera_Simulation.set_analog_gain(self, analog_gain):
Sets the analog gain of the simulated camera.

Camera_Simulation.get_awb_ratios(self):
Gets the auto white balance ratios for the simulated camera.

Camera_Simulation.set_wb_ratios(self, wb_r=None, wb_g=None, wb_b=None):
Sets the white balance ratios for the simulated camera.

Camera_Simulation.start_streaming(self):
Starts the simulated camera streaming.

Camera_Simulation.stop_streaming(self):
Stops the simulated camera streaming.

Camera_Simulation.set_continuous_acquisition(self):
Sets the simulated camera to continuous acquisition mode.

Camera_Simulation.set_software_triggered_acquisition(self):
Sets the simulated camera to software-triggered acquisition mode.

Camera_Simulation.set_hardware_triggered_acquisition(self):
Sets the simulated camera to hardware-triggered acquisition mode.

Camera_Simulation.send_trigger(self):
Sends a trigger signal to the simulated camera and generates a frame.

Camera_Simulation.read_frame(self):
Reads the current frame from the simulated camera.

Camera_Simulation.set_pixel_format(self, format):
Sets the pixel format of the simulated camera.
File: ./software/control/ImSwitch/naparitools.py
Here are the method headers with docstring descriptions extracted from the provided Python file:

def addNapariGrayclipColormap():
    """Adds a 'grayclip' colormap to Napari's available colormaps."""

class EmbeddedNapari(napari.Viewer):
    """Napari viewer to be embedded in non-napari windows. Includes feature to protect certain layers from removal."""

    def __init__(self, *args, show=False, **kwargs):
        """Initialize the embedded Napari viewer."""

    def add_image(self, *args, protected=False, **kwargs):
        """Add an image layer, with option to protect it from removal."""

    def get_widget(self):
        """Get the Qt widget for the viewer."""

class NapariBaseWidget(QtWidgets.QWidget):
    """Base class for Napari widgets."""

    def __init__(self, napariViewer):
        """Initialize the base Napari widget."""

    @classmethod
    def addToViewer(cls, napariViewer, position='left'):
        """Add this widget to the specified Napari viewer."""

    def addItemToViewer(self, item):
        """Add an item to the Napari viewer."""

class NapariUpdateLevelsWidget(NapariBaseWidget):
    """Napari widget for auto-levelling the currently selected layer with a single click."""

    def __init__(self, napariViewer):
        """Initialize the update levels widget."""

    def _on_update_levels(self):
        """Update contrast limits for selected layers."""

class NapariResetViewWidget(NapariBaseWidget):
    """Napari widget for resetting the dimensional view of the currently selected layer."""

    def __init__(self, napariViewer):
        """Initialize the reset view widget."""

    def _on_reset_view(self):
        """Reset the viewer's view."""

    def _on_reset_axis_order(self):
        """Reset the axis order to default."""

    def _on_set_axis_order(self):
        """Set a custom axis order."""

class NapariShiftWidget(NapariBaseWidget):
    """Napari widget for shifting the currently selected layer by a user-defined number of pixels."""

    def __init__(self, napariViewer):
        """Initialize the shift widget."""

    def _on_up(self):
        """Shift the selected layer up."""

    def _on_right(self):
        """Shift the selected layer right."""

    def _on_down(self):
        """Shift the selected layer down."""

    def _on_left(self):
        """Shift the selected layer left."""

    def _on_reset(self):
        """Reset the layer position."""

    def _do_shift(self, xDist, yDist):
        """Perform the shift operation."""

    def _get_shift_distance(self):
        """Get the current shift distance."""

class VispyBaseVisual(QtCore.QObject):
    """Base class for Vispy visuals."""

    def __init__(self):
        """Initialize the base Vispy visual."""

    def attach(self, viewer, view, canvas, parent=None, order=0):
        """Attach the visual to a Napari viewer."""

    def detach(self):
        """Detach the visual from the viewer."""

    def setVisible(self, value):
        """Set the visibility of the visual."""

    def show(self):
        """Show the visual."""

    def hide(self):
        """Hide the visual."""

class VispyROIVisual(VispyBaseVisual):
    """Vispy visual for displaying and interacting with a Region of Interest (ROI)."""

    def __init__(self, rect_color='yellow', handle_color='orange'):
        """Initialize the ROI visual."""

    def attach(self, viewer, view, canvas, parent=None, order=0):
        """Attach the ROI visual to a Napari viewer."""

    def on_mouse_press(self, event):
        """Handle mouse press events for ROI interaction."""

    def on_mouse_move(self, event):
        """Handle mouse move events for ROI interaction."""

    def on_mouse_release(self, event):
        """Handle mouse release events for ROI interaction."""

class VispyLineVisual(VispyBaseVisual):
    """Vispy visual for displaying and interacting with a line."""

    def __init__(self, color='yellow', movable=False):
        """Initialize the line visual."""

    def attach(self, viewer, view, canvas, parent=None, order=0):
        """Attach the line visual to a Napari viewer."""

    def on_mouse_press(self, event):
        """Handle mouse press events for line interaction."""

    def on_mouse_move(self, event):
        """Handle mouse move events for line interaction."""

    def on_mouse_release(self, event):
        """Handle mouse release events for line interaction."""

class VispyGridVisual(VispyBaseVisual):
    """Vispy visual for displaying a grid."""

    def __init__(self, color='yellow'):
        """Initialize the grid visual."""

    def attach(self, viewer, view, canvas, parent=None, order=0):
        """Attach the grid visual to a Napari viewer."""

    def update(self, shape):
        """Update the grid shape."""

class VispyCrosshairVisual(VispyBaseVisual):
    """Vispy visual for displaying a crosshair."""

    def __init__(self, color='yellow'):
        """Initialize the crosshair visual."""

    def attach(self, viewer, view, canvas, parent=None, order=0):
        """Attach the crosshair visual to a Napari viewer."""

    def on_mouse_press(self, event):
        """Handle mouse press events for crosshair interaction."""

    def on_mouse_move(self, event):
        """Handle mouse move events for crosshair interaction."""

    def on_mouse_release(self, event):
        """Handle mouse release events for crosshair interaction."""

class VispyScatterVisual(VispyBaseVisual):
    """Vispy visual for displaying scatter points."""

    def __init__(self, color='red', symbol='x'):
        """Initialize the scatter visual."""

    def attach(self, viewer, view, canvas, parent=None, order=0):
        """Attach the scatter visual to a Napari viewer."""

    def setData(self, x, y):
        """Set the scatter point data."""
File: ./software/control/gxipy/gxiapi.py
Here are the method headers with docstring descriptions extracted from the Python file:

DeviceManager.__get_device_info_list:
"""
:brief      Convert GxDeviceBaseInfo and GxDeviceIPInfo to device info list
:param      base_info:  device base info list[GxDeviceBaseInfo]
:param      ip_info:    device ip info list[GxDeviceIPInfo]
:param      num:        device number
:return:    device info list
"""

DeviceManager.__get_ip_info:
"""
:brief      Get the network information
"""

DeviceManager.update_device_list:
"""
:brief      enumerate the same network segment devices
:param      timeout:    Enumeration timeout, range:[0, 0xFFFFFFFF]
:return:    dev_num:    device number
            device_info_list: all device info list
"""

DeviceManager.update_all_device_list:
"""
:brief      Enumerate devices on different network segments
:param      timeout:    Enumeration timeout, range:[0, 0xFFFFFFFF]
:return:    dev_num:    device number
            device_info_list:   all device info list
"""

DeviceManager.get_device_number:
"""
:brief      Get device number
:return:    device number
"""

DeviceManager.get_device_info:
"""
:brief      Get all device info
:return:    info_dict:      device info list
"""

DeviceManager.open_device_by_index:
"""
:brief      open device by index
            USB3 device return U3VDevice object
            USB2 device return U2Device object
            GEV  device return GEVDevice object
:param      index:          device index must start from 1
:param      access_mode:    the access of open device
:return:    Device object
"""

DeviceManager.__get_device_class_by_sn:
"""
:brief:     1.find device by sn in self.__device_info_list
            2.return different objects according to device class
:param      sn:      device serial number
:return:    device class
"""

DeviceManager.open_device_by_sn:
"""
:brief      open device by serial number(SN)
            USB3 device return U3VDevice object
            USB2 device return U2Device object
            GEV device return GEVDevice object
:param      sn:             device serial number, type: str
:param      access_mode:    the mode of open device[GxAccessMode]
:return:    Device object
"""

DeviceManager.__get_device_class_by_user_id:
"""
:brief:     1.find device according to sn in self.__device_info_list
            2.return different objects according to device class
:param      user_id:        user ID
:return:    device class
"""

DeviceManager.open_device_by_user_id:
"""
:brief      open device by user defined name
            USB3 device return U3VDevice object
            GEV  device return GEVDevice object
:param      user_id:        user defined name, type:str
:param      access_mode:    the mode of open device[GxAccessMode]
:return:    Device object
"""

DeviceManager.open_device_by_ip:
"""
:brief      open device by device ip address
:param      ip:             device ip address, type:str
:param      access_mode:    the mode of open device[GxAccessMode]
:return:    GEVDevice object
"""

DeviceManager.open_device_by_mac:
"""
:brief      open device by device mac address
:param      mac:            device mac address, type:str
:param      access_mode:    the mode of open device[GxAccessMode]
:return:    GEVDevice object
"""

Feature.__get_name:
"""
brief:  Getting Feature Name
return: Success:    feature name
        Failed:     convert feature ID to string
"""

Feature.is_implemented:
"""
brief:  Determining whether the feature is implemented
return: is_implemented
"""

Feature.is_readable:
"""
brief:  Determining whether the feature is readable
return: is_readable
"""

Feature.is_writable:
"""
brief:  Determining whether the feature is writable
return: is_writable
"""

IntFeature.__range_dict:
"""
:brief      Convert GxIntRange to dictionary
:param      int_range:  GxIntRange
:return:    range_dicts
"""

IntFeature.get_range:
"""
:brief      Getting integer range
:return:    integer range dictionary
"""

IntFeature.get:
"""
:brief      Getting integer value
:return:    integer value
"""

IntFeature.set:
"""
:brief      Setting integer value
:param      int_value
:return:    None
"""

FloatFeature.__range_dict:
"""
:brief      Convert GxFloatRange to dictionary
:param      float_range:  GxFloatRange
:return:    range_dicts
"""

FloatFeature.get_range:
"""
:brief      Getting float range
:return:    float range dictionary
"""

FloatFeature.get:
"""
:brief      Getting float value
:return:    float value
"""

FloatFeature.set:
"""
:brief      Setting float value
:param      float_value
:return:    None
"""

EnumFeature.get_range:
"""
:brief      Getting range of Enum feature
:return:    enum_dict:    enum range dictionary
"""

EnumFeature.get:
"""
:brief      Getting value of Enum feature
:return:    enum_value:     enum value
            enum_str:       string for enum description
"""

EnumFeature.set:
"""
:brief      Setting enum value
:param      enum_value
:return:    None
"""

BoolFeature.get:
"""
:brief      Getting bool value
:return:    bool value[bool]
"""

BoolFeature.set:
"""
:brief      Setting bool value
:param      bool_value[bool]
:return:    None
"""

StringFeature.get_string_max_length:
"""
:brief      Getting the maximum length that string can set
:return:    length:     the maximum length that string can set
"""

StringFeature.get:
"""
:brief      Getting string value
:return:    strings
"""

StringFeature.set:
"""
:brief      Setting string value
:param      input_string[string]
:return:    None
"""

BufferFeature.get_buffer_length:
"""
:brief      Getting buffer length
:return:    length:     buffer length
"""

BufferFeature.get_buffer:
"""
:brief      Getting buffer data
:return:    Buffer object

"""

BufferFeature.set_buffer:
"""
:brief      Setting buffer data
:param      buf:    Buffer object
:return:    None
"""

CommandFeature.send_command:
"""
:brief      Sending command
:return:    None
"""

Device.stream_on:
"""
:brief      send start command, camera start transmission image data
:return:    none
"""

Device.stream_off:
"""
:brief      send stop command, camera stop transmission image data
:return:    none
"""

Device.export_config_file:
"""
:brief      Export the current configuration file
:param      file_path:      file path(type: str)
:return:    none
"""

Device.import_config_file:
"""
:brief      Imported configuration file
:param      file_path:  file path(type: str)
:param      verify:     If this value is true, all the imported values will be read out
                        and checked for consistency(type: bool)
:return:    none
"""

Device.close_device:
"""
:brief      close device, close device handle
:return:    None
"""

Device.get_stream_channel_num:
"""
:brief      Get the number of stream channels supported by the current device.
:return:    the number of stream channels
"""

Device.register_device_offline_callback:
"""
:brief      Register the device offline event callback function.
:param      call_back:  callback function
:return:    none
"""

Device.unregister_device_offline_callback:
"""
:brief      Unregister the device offline event callback function.
:return:    none
"""

Device.__on_device_offline_call_back:
"""
:brief      Device offline event callback function with an unused c_void_p.
:return:    none
"""

Device.register_capture_callback:
"""
:brief      Register the capture event callback function.
:param      cap_call:  callback function
:return:    none
"""

Device.unregister_capture_callback:
"""
:brief      Unregister the capture event callback function.
:return:    none
"""

Device.__on_capture_call_back:
"""
:brief      Capture event callback function with capture date.
:return:    none
"""

DataStream.set_acquisition_buffer_number:
"""
:brief      set the number of acquisition buffer
:param      buf_num:   the number of acquisition buffer, range:[1, 0xFFFFFFFF]
"""

DataStream.get_image:
"""
:brief          Get an image, get successfully create image class object
:param          timeout:    Acquisition timeout, range:[0, 0xFFFFFFFF]
:return:        image object
"""

RGBImage.image_improvement:
"""
:brief:     Improve image quality of the object itself
:param      color_correction_param:     color correction param address
                                        (get from Device.ColorCorrectionParam.get_int())
:param      contrast_lut:               contrast lut
:param      gamma_lut:                  gamma lut
:return:    None
"""

RGBImage.get_numpy_array:
"""
:brief:     Return data as a numpy.Array type with dimension Image.height * Image.width * 3
:return:    numpy.Array objects
"""

RGBImage.get_image_size:
"""
:brief      Get RGB data size
:return:    size
"""

RawImage.__get_bit_depth:
"""
:brief      Calculate pixel depth based on pixel format
:param      pixel_format
:return:    pixel depth
"""

RawImage.__get_pixel_color_filter:
"""
:brief      Calculate pixel color filter based on pixel format
:param      pixel_format
:return:    pixel color filter
"""

RawImage.__pixel_format_raw16_to_raw8:
"""
:brief      convert raw16 to raw8, the pixel format need convert to 8bit bayer format
:param      pixel_format(10bit, 12bit, 16bit)
:return:    pixel_format(8bit)
"""

RawImage.__raw16_to_raw8:
"""
:brief      convert raw16 to raw8
:param      pixel_bit_depth     pixel bit depth
:param      valid_bits:         data valid digit[DxValidBit]
:return:    RAWImage object
"""

RawImage.__raw8_to_rgb:
"""
:brief      convert raw8 to RGB
:param      raw8_image          RAWImage object, bit depth is 8bit
:param      convert_type:       Bayer convert type, See detail in DxBayerConvertType
:param      pixel_color_filter: pixel color filter, See detail in DxPixelColorFilter
:param      flip:               Output image flip flag
                                True: turn the image upside down
                                False: do not flip
:return:    RAWImage object
"""

RawImage.convert:
"""
:brief      Image format convert
:param      mode:           "RAW8":     convert raw16 RAWImage object to raw8 RAWImage object
                            "RGB":   convert raw8 RAWImage object to RGBImage object
:param      flip:           Output image flip flag
                            True: turn the image upside down
                            False: do not flip
:param      valid_bits:     Data valid digit, See detail in DxValidBit, raw8 don't this param
:param      convert_type:   Bayer convert type, See detail in DxBayerConvertType
:return:    return image object according to mode parameter
"""

RawImage.get_numpy_array:
"""
:brief      Return data as a numpy.Array type with dimension Image.height * Image.width
:return:    numpy.Array objects
"""

RawImage.get_data:
"""
:brief      get Raw data
:return:    raw data[string]
"""

RawImage.save_raw:
"""
:brief      save raw data
:param      file_path:      file path
:return:    None
"""

RawImage.get_status:
"""
:brief      get raw data status
:return:    status
"""

RawImage.get_width:
"""
:brief      get width of raw data
:return:    width
"""

RawImage.get_height:
"""
:brief     get height of raw data
:return:
"""

RawImage.get_pixel_format:
"""
:brief      Get image pixel format
:return:    pixel format
"""

RawImage.get_image_size:
"""
:brief      Get raw data size
:return:    size
"""

RawImage.get_frame_id:
"""
:brief      Get  frame id of raw data
:return:    frame id
"""

RawImage.get_timestamp:
"""
:brief      Get timestamp of raw data
:return:    timestamp
"""

Utility.get_gamma_lut:
"""
:brief      Get gamma lookup table
:param      gamma:  Gamma value, range: [0.1, 10.0]
:return:    Buffer object containing gamma LUT
"""

Utility.get_contrast_lut:
"""
:brief      Get contrast lookup table
:param      contrast:  Contrast value, range: [-50, 100]
:return:    Buffer object containing contrast LUT
"""
