import * as fs from 'fs'
import * as fsPromises from 'fs/promises'
import { join } from 'path'
import { flatten } from 'lodash'
import type { Dispatch } from './types'
import {
  robotMassStorageDeviceAdded,
  robotMassStorageDeviceEnumerated,
  robotMassStorageDeviceRemoved,
} from './actions'
const FLEX_USB_MOUNT_DIR = '/media/'
const FLEX_USB_DEVICE_DIR = '/dev/'
const FLEX_USB_MOUNT_FILTER = /sd[a-z]+[0-9]+$/
const MOUNT_ENUMERATION_DELAY_MS = 1000

// These directories are generated by OSX and contain entries for all
// the files that were deleted from a mass storage device, or search index
// data
const isWeirdDirectoryAndShouldSkip = (dirName: string): boolean =>
  ['.Trashes', '.Spotlight']
    .map(keyword => dirName.includes(keyword))
    .reduce((prev, current) => prev || current, false)

const enumerateMassStorage = (path: string): Promise<string[]> =>
  fsPromises
    .readdir(path)
    .then(entries =>
      entries.length === 0
        ? new Promise<void>(resolve =>
            setTimeout(resolve, MOUNT_ENUMERATION_DELAY_MS)
          )
        : new Promise<void>(resolve => {
            resolve()
          })
    )
    .then(() => fsPromises.readdir(path, { withFileTypes: true }))
    .then(entries =>
      Promise.all(
        entries.map(entry =>
          entry.isDirectory() && !isWeirdDirectoryAndShouldSkip(entry.name)
            ? enumerateMassStorage(join(path, entry.name))
            : new Promise<string[]>(resolve => {
                resolve([join(path, entry.name)])
              })
        )
      )
    )
    .catch(() => [])
    .then(flatten)

export function watchForMassStorage(dispatch: Dispatch): () => void {
  console.log('watching for mass storage')
  let prevDirs: string[] = []
  const handleNewlyPresent = (path: string): Promise<string> => {
    dispatch(robotMassStorageDeviceAdded(path))
    return enumerateMassStorage(path)
      .then(contents => {
        dispatch(robotMassStorageDeviceEnumerated(path, contents))
      })
      .then(() => path)
  }

  const rescan = (dispatch: Dispatch): Promise<unknown> =>
    fsPromises
      .readdir(FLEX_USB_MOUNT_DIR)
      .then(entries => {
        const sortedEntries = entries.sort()
        const newlyPresent = sortedEntries.filter(
          entry => !prevDirs.includes(entry)
        )
        const newlyAbsent = prevDirs.filter(
          entry => !sortedEntries.includes(entry)
        )
        return Promise.all([
          ...newlyAbsent.map(entry => {
            if (entry.match(FLEX_USB_MOUNT_FILTER)) {
              dispatch(
                robotMassStorageDeviceRemoved(join(FLEX_USB_MOUNT_DIR, entry))
              )
            }
            return null
          }),
          ...newlyPresent.map(entry => {
            if (entry.match(FLEX_USB_MOUNT_FILTER)) {
              return handleNewlyPresent(join(FLEX_USB_MOUNT_DIR, entry))
            }
            return null
          }),
        ])
      })
      .then(present => {
        prevDirs = present.filter((entry): entry is string => entry !== null)
      })

  const mediaWatcherCreator = (): fs.FSWatcher | null => {
    try {
      return fs.watch(
        FLEX_USB_MOUNT_DIR,
        { persistent: true },
        (event, fileName) => {
          if (!!!fileName) {
            rescan(dispatch)
            return
          }
          if (!fileName.match(FLEX_USB_MOUNT_FILTER)) {
            return
          }
          const fullPath = join(FLEX_USB_MOUNT_DIR, fileName)
          fsPromises
            .stat(fullPath)
            .then(info => {
              if (!info.isDirectory) {
                return
              }
              if (prevDirs.includes(fullPath)) {
                return
              }
              console.log(`New mass storage device ${fileName} detected`)
              prevDirs.push(fullPath)
              return handleNewlyPresent(fullPath)
            })
            .catch(() => {
              if (prevDirs.includes(fullPath)) {
                console.log(`Mass storage device at ${fileName} removed`)
                prevDirs = prevDirs.filter(entry => entry !== fullPath)
                dispatch(robotMassStorageDeviceRemoved(fullPath))
              }
            })
        }
      )
    } catch {
      return null
    }
  }

  const mediaWatcher = mediaWatcherCreator()

  const devWatcher = fs.watch(
    FLEX_USB_DEVICE_DIR,
    { persistent: true },
    (event, fileName) => {
      if (!!!fileName) return
      if (!fileName.match(FLEX_USB_MOUNT_FILTER)) return
      const fullPath = join(FLEX_USB_DEVICE_DIR, fileName)
      const mountPath = join(FLEX_USB_MOUNT_DIR, fileName)
      fsPromises.stat(fullPath).catch(() => {
        if (prevDirs.includes(mountPath)) {
          console.log(`Mass storage device at ${fileName} removed`)
          prevDirs = prevDirs.filter(entry => entry !== mountPath)
          dispatch(
            robotMassStorageDeviceRemoved(join(FLEX_USB_MOUNT_DIR, fileName))
          )
          // we don't care if this fails because it's racing the system removing
          // the mount dir in the common case
          fsPromises.unlink(mountPath).catch(() => {})
        }
      })
    }
  )

  rescan(dispatch)
  return () => {
    mediaWatcher != null && mediaWatcher.close()
    devWatcher.close()
  }
}
